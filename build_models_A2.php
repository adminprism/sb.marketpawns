<?php
set_time_limit(500);
ini_set('memory_limit', '1024M');
//file_put_contents("TMP_POST2___.json",json_encode($_POST));
//file_put_contents("TMP_POST2_m1__.json",$_POST['Models1']);
DEFINE("ALGORITHM_NUM", 2); // номер алгоритма
DEFINE("BAR_50", 50); // количество бар, глубина поиска точки 3 (в данном файле - это бар последнего пересечения ценой уровня т.1) (пункт 1 алгоритма)
DEFINE("BAR_50_321", 50); // количество бар, глубина поиска точки 5 в пункте 3_2_1
DEFINE("BAR_T3_50", 50); // количество бар, непр. глубина поиска точки т3 (пункт 2 алгоритма)
DEFINE("BAR_T3_150", 150); // количество бар, глубина поиска точки т3 (пункт 2 алгоритма)
DEFINE("A2_BAR_T5_50", 50); // количество бар, непр. глубина поиска ППЦ
DEFINE("A2_BAR_T5_150", 150); // количество бар, глубина  поиска ППЦ
DEFINE("A2_BAR_T3_300", 300); // количество бар, глубина поиска бара последнего пересечения ценой (БПУ) уровня т.1
DEFINE("PAR246aux", 2); // количество бар, глубина поиска точки т3 (пункт 2 алгоритма)
DEFINE("P12", 0.5); // Минимальное расстояния между т.1 и т.2 Пресуппозиции
DEFINE("B24to46", 0.5); // Минимальное отношение т.2-т.4 к т.4-т.6 ВМП
DEFINE("P23to34", 10); // Соотношение по времени 23 к 34 (ограничение при поиске БО)
DEFINE("STEP10LIMIT", 100); // Глубина поиска пересечения ценой ЛТ в шаге 10
DEFINE("CALC_G3_DEPTH", 150); // глубина поиска при определении G3

// фиксированные поля в $State, их не очищаем при переходах между пунктами алгоритма
DEFINE("KEYS_LIST_STATIC", "v,mode,curBar,next_step,cnt,flat_log,status,param,split");
DEFINE("SHOW_LOG_STATISTICS", true); //служебная константа - если true - выводим доп.ветку в res - сколько раз вызывалась myLog из разных строк программы - для оптимизации лога (когда очень большой), поиск самых частых обращений
define("WRITE_LOG", 9);
error_reporting(-1); //error_reporting(E_ALL & ~E_NOTICE);
ini_set('display_errors', 'On');

require_once 'src/build_models_common.php';

$modelNextId = 1;
$res = []; // ветвистый асс. массив результата
$res['Algorithm_num'] = ALGORITHM_NUM; // флаг - номер алгоритма, просто ссобщаем информацию джава-скрипту - какой из алгоритмов вернул результат
$res['Errors'] = []; // обработчиком исключению сюда пишутся ошибки исполнения php - потом при обработке shutdown эта ветка передается в res
$res['info'] = [];
$res['info']['calcTimes'] = [];
$res['info']['splitting'] = []; // справочная (отладочная) информация - сколько было расщепления на разных steps
$res['log_selected_bar'] = []; // подробный лог для выбранного бара в качестве т3 - когда подробный лог выключен, сюда все равно пишется лог по конкретному выбранному бару
//$res['A2_log_t3'] = [];
$lastT3fromT1 = [];
$res['log'] = []; // общий лог, не привязанный к State (в наст момент не используется, но для отладки туда можно что-то вывполить $res['log'][]="text")
$res['Models2'] = []; // разервируем ветку для моделей из первого алгоритма- при выходе, она заполняется в shutdown()
$res['Models'] = []; // разервируем ветку для найденных моделей - при выходе, она заполняется в shutdown() (резервируем для сохранения очередности веток при формировании res - для удобства просмотра)
if (SHOW_LOG_STATISTICS) $res['FlatLog_Statistics'] = []; // если нужно, то создаем ветку для анализа количества вызовов myLog из разных строк программы
//$res['TMP_IDinners_cnt']=0;

//$lastT3fromT1 = []; Е: не нашел упоминания в дальнейшем тексте, пока сакомментарил

//$A2_lastT5fromT3 = []; // надо подумать, как её уставнавливать, в 1-ом алгоритме просто 1 000 000 000 *E: не понял, что это

//if(!is_ajax()){$res['Errors']='Запускать можно только через AJAX, сорри.'; die();}

$splitCnt = 1; // счетчик отпочковавшихся веток при расщиплениях
if (!isset($_POST['paramArr'])) throw new Exception('paramArr is not set!');
$paramArr = $_POST['paramArr']; // J берет из джава скрипта параметры модели? - Е: просто набор параметров при запуске алгоритма- режим, тек.бар, нужен ли подробный лог
$mode = isset($paramArr['mode']) ? $paramArr['mode'] : "mode1"; // J Если не был установлен мод, устанавливает "mode1". За установку мода отвечает .js файл
$selectedBar = isset($paramArr['selectedBar']) ? intval($paramArr['selectedBar']) : 0; // J Берет  'selectedBar' из джава, либо устанавливает на 0
DEFINE("selectedBar", $selectedBar);
if ($mode == 'mode1') $mode = 'all';  // считать все модели
if ($mode == 'mode2') $mode = 'last'; // искать по одной последней модели ( low + high ) перед selectedBar
if ($mode == 'mode3') $mode = 'selected'; // искать только одну модель, принимая sleectedBar в качестве опорной точки (т3)

$res['paramArr'] = $paramArr; // просто полученные параметры шлем обратно в ответе, для наглядности при отладке
$res['info']['mode'] = $mode;  // также шлем ооратно используемые при работе параметры
$res['info']['selectedBar'] = $selectedBar;

if (!isset($_POST['Chart'])) throw new Exception('Chart is not set!');  // "забыли передать сам чарт - выход
$Chart = json_decode($_POST['Chart'], true); //  J полностью берет из джава скрипта график

if (isset($paramArr['pips']))$pips=$paramArr['pips'];  // размер пипса - если передали, используем его иначе определяем
else $pips = calcPips($Chart);
if($pips<0.00000001) throw new Exception('!!! pips==0 ('.$pips.')');

// 2023-09-01 добавлена запись результата (копии) в текстовый файл - в параметре можно задать отмену или указать имя файла, наприм ер
if (isset($paramArr['text_res'])){
    if($paramArr['text_res']!="0"){
        if($paramArr['text_res']==1)DEFINE("NEED_TEXT_RES",true); // задан как 1 - задаем true - имя текстового файла генерится автоматически (с указанием даты-времени)
        else DEFINE("NEED_TEXT_RES",$paramArr['text_res']); // задан фиксированный файл
    } // если задан 0, то значит при выходе результат в текстовом файле не сохраняем
}
else DEFINE("NEED_TEXT_RES","tmp_log/_res_Alg2_{DANDT}.txt"); // ВНИМАНИЕ! ЗНАЧЕНИЕ ПО УМОЛЧАНИЮ :
// false = не писать
// true = каждый раз в новый файл с указанием времени (автонаименование)
// ЛИБО указать имя файла (напр. "tmp_log/_res_Alg2_{DANDT}.txt") , если содержит {DANDT} - то будет подставлена дата и время



$Models_Alg1 = json_decode($_POST['Models1'], true); //  переданные модели Алгоритма_1 - потом будем использовать, пока просто проходит сквозняком и возвращается как модели первого алгоритма в 'Models' , результат данного расчета в 'Modelds2'
//$ttttt=JSON_log($Models_Alg1,"___Models_Alg1.json");
DEFINE("nBars", count($Chart)); // число баров на полученном графике пихаем в константу

//$res['Chart']=count($Chart);
$res['info']['count'] = nBars; //count($Chart);

// диспетчер основного алгоритма
$State = [
    'status' => [], // статусы модели
    //'nBars' => count($Chart), - лишняя переменная, засоряет $State - убрал в константу
    'split' => 0,
    'mode' => $mode,
    //'selectedBar' => $selectedBar, //- лишняя переменная, засоряет $State - убрал в константу
    'curBar' => 0, // текущий бар, заполняется далее
    'next_step' => 'A2_step_1', // какой шаг следующий - меняется при выполнении проверок на текущем шаге, stop=завершение ветки
    'cnt' => 0, // просто счетчик вызова различных процедур (шагов алгоритма) для данного State
    'flat_log' => [], // плоский лог - массив строк по порядку логирования - для каждого State свой лог
    'param' => [] // параметры моделей
];  // в массив $State пишем текущее состояние расчетов при движении по алгоритму
if (isset($paramArr['log'])  && $paramArr['log'] == 0) unset($State['flat_log']); // убираем ветку flat_log, если не указан подробный лог (галочка в js)

$State = myLog($State, Date("Y-m-d H:i:s") . "> Start Algorithm_2 ");
$State['curBar'] = ($selectedBar == 0 || $mode == 'all') ? (nBars - 10) : $selectedBar; // первая точка для проверки в кандидаты (1) - 10-й бар справa, либо выбранный бар
$States = [];
$States[] = $State; // первый стэйт

$toRepeat = true;
while ($toRepeat) { // пока $toRepeat != false

    $toRepeat = false; //если ветвления алгоритма не будет, отработаем все состояния и выход
    foreach ($States as $pk => $pv) { // $pk здесь - это перебор $State, а $pv - элементы
        $tmp_cnt = 0;
        while (
            isset($States[$pk]) //  пока есть хотя бы один элемент в $States, у которого...(смотрим следующую строку)
            && $States[$pk]['next_step'] !== 'stop'
            && $tmp_cnt < 25000 //ограничиваем количество итераций для
        ) {
            $tmp_cnt++;
            $States[$pk]['cnt']++; // счетчик итераций диспетчера, пока не знаю, зачем он нужен
            $start_proc_time = microtime(true);
            $functionName = $States[$pk]['next_step'];  //имя процедуры-расчета следующего этапа алгоритма (своеобразная диспетчеризация)
            $res['info']['last_function'] = $functionName . " State N $pk  tmp_cnt=$tmp_cnt"; // для отладки - ловим функию, на которой зависает (если, конечно, зависает :)
            $curState = $pk;
            $curSplit = $States[$pk]['split'];
            $States_tmp = $functionName($States[$pk]); // вызов нужной функции для очередного step - имя этой функции было в поле "next_step"
            $res['info']['last_function'] .= ' done'; // показали, что из функцими вышли
            $res['info']['last_function_ok'] = $functionName; // показали, что из функцими вышли
            $finish_proc_time = microtime(true); // время выполнения очередного шага
            if (!isset($res['info']['calcTimes'][$functionName . '_time'])) {  // если не указано время расчета одной из процедур в подмассиве calcTimes, то...
                $res['info']['calcTimes'][$functionName . '_time'] = $finish_proc_time - $start_proc_time; // рассчитываем его
                $res['info']['calcTimes'][$functionName . '_cnt'] = 1;  // т.к. при проверке выявили, что время расчета процедуры не указано, то устанавливаем счетчик на 1
            } else {
                $res['info']['calcTimes'][$functionName . '_cnt']++; // в случае, когда время расчета было указано, то добавляем к счетчику +1
                $res['info']['calcTimes'][$functionName . '_time'] += ($finish_proc_time - $start_proc_time);
            }
            if (!is_array($States_tmp)) $res['log'][] = "ERROR! - not array in result. functionName=" . $functionName; // вернулся и не State и не массив (ошибка)
            else {
                if (isset($States_tmp['v'])) { // вернулся одиночный State
                    $States[$pk] = $States_tmp;
                } //  вернулся не массив а один State
                else { // было расщепление
                    if (count($States_tmp) > 1)
                        if (isset($res['info']['splitting'][$functionName])) $res['info']['splitting'][$functionName] += count($States_tmp) - 1;
                        else $res['info']['splitting'][$functionName] = count($States_tmp) - 1;
                    $States[$pk] = $States_tmp[0]; // первый элемент из вернувшегося массива States пишем на старое место
                    if (count($States_tmp) > 1) { // произошло разветвление алгоритма, вместо одного вернулось >=2 состояния - начиная со второго - создаем новые State в массиве $States
                        for ($n = 1; $n < count($States_tmp); $n++) $States[] = $States_tmp[$n]; // добавляем новый State в массив
                        $toRepeat = true;
                    }
                }
            } // вернулось нормально значение $States_tmp - массив  из State  или один State
        }
    }
}
$res['States'] = $States;
//$res_=json_encode($res, true);
//$r=file_put_contents($res_,"res____.json");
//$res['r']=$r;
//file_put_contents($r,"res_____1.json");


die();





function A2_myLog_start($State, $step)
{
    global $res;
    //$curBar = $State['curBar'];
    //$v = $State['v'];
    //$txt = "[" . $State['split'] . "] *** step $step (".$State['curBar']." ".$State['v'].") t3";
    $txt = "*** step $step (" . $State['curBar'] . " " . $State['v'] . ") t3";
    $tArr = [];
    if (isset($State['t1'])) $tArr[] = 't1';  // J по всей видимости следующему пустому элементу массива присваивается значение соотв. 't'
    if (isset($State['t2'])) $tArr[] = 't2';  // Е: сообщаем в лог при старте нового step - значения основных важных точек, найденных на тек.момент + low или high модель строим
    if (isset($State['t4'])) $tArr[] = 't4';
    if (isset($State['t5'])) $tArr[] = 't5';
    if (isset($State['t3\''])) $tArr[] = 't3\'';
    if (isset($State['t3"'])) $tArr[] = 't3"';
    if (isset($State['t5"'])) $tArr[] = 't5"';
    foreach ($tArr as $pk => $pv) {
        $txt .= "-" . $pv;
    }
    $s = $State['t3'];
    foreach ($tArr as $pk => $pv) { // J по очереди элменты массива в $tArr сливаются через тире с переменной $s (которая содержит значение бара т.3)
        $s .= "-" . $State[$pv];
    }
    $State = myLog($State, $txt . ": " . $s);
    //if (!isset($State['t3']) || selectedBar == $State['t3']) $res['log_t3'][] = $txt . ": " . $s;  Е: убрал и заменил прямую запись в пред.строке на вызов myLog - там уже, к случае необхоодимости, пишем в лог.выбранного бара
    return ($State);
}

////////ALG2//////////////////////

function A2_step_1($State)
{ // Пункт 1 алг.2 ПОИСК ТОЧКИ 3 ВМП И НАЧАЛЬНОЙ ТОЧКИ ПРЕДШ. ТРЕНДА
    // функция принимает cur_bar и начиная  с него ишет в глубь подтвержденную т3, если доходит до начала графика, то выход, иначе - на step2 + расщепление - поиск новой т3 начиная c (т3-1)

    global $splitCnt;
    $State['t3'] = $State['curBar']; // заполняем State['t3'] просто что-бы можно было вызвать лог:  (State = A2_myLog_start($State, "1");)

    if (!isset($State['v'])) { // первый вызов (если НЕ присвоен $State['v'] - "расщепляем" на веткии high и low
        $State = myLog($State, 'Расщепление на high и low ');
        $state2 = $State;
        $State['v'] = 'low';
        $state2['v'] = 'high';
        $state2['split'] = $splitCnt++; // подсчет отпочковавшейся ветки
        return ([$State, $state2]); // возворащаемся на step_1 уже двумя стартовыми ветками - low & high
    }
    $v = $State['v'];
    // если уже не первый запуск, то двигаемся дальше
    $State = A2_myLog_start($State, "1");
    if ($State['curBar'] < 3) { // Если анализируемый бар ближе к началу графика, чем 3 бара, то остановка расчета
        $State = myLog($State, " СТОП: дошли до начала графика");
        $State['next_step'] = 'stop';
        return ($State);
    }

    //$cont = true;
    for ($i = $State['curBar']; $i > 3; $i--) {
        $State['t3'] = $i; // checking out potential t3 bar 
        if (is_extremum($i, $v)) { // checking if current bar is extremum
            $State = myLog($State, "Найден экстремум ($v) - кандидат в t3: $i"); //  было myLog_selected_bar \
            $price_3 = low($i, $v); // значение бара, которое будет проверяться в качестве т.3
            // проверка кандидита на т.3
            // $cont = true;
            $is_lcb3_found = false; // lcb - level confirmation bar, БПУ - бар подвтерждающий уровень
            // 1.2. Далее программа проверяет поочередно бары справа налево (т.е. в прошлое)
            for ($j = $i - 1; $j > 0 && $j > ($i - A2_BAR_T3_300); $j--) // либо проходим BAR_300 бар либо до начала графика
            {
                // if (low($j, $v) == $price_3)  {
                // $State = myLog($State, "Найден более раниий экстремум ($j , $v) - кандидат в т.3 на уровне рассматриваемого кандадидата: $i - low($i, $v)"); //  было myLog_selected_bar \
                // continue 2;
                // }
                if ( // ищем последнее пересечение бара т.3
                    low($j, $v) < $price_3 // low рассматриваемого бара меньше т.3 (low) и... (след. строка)
                    // && high($j, $v) >= $price_3 // ... хай рассм. бара выше т.3 (low)
                ) {
                    $is_lcb3_found = true;
                    break; // прерывает поиск, если подходящая точка найдена
                }
            };

            if ($is_lcb3_found) { // 1.2.1. Найдена точка последнего пересечения(пробоя) ценой уровня кандидата в т.3.
                $State['param']['PREVdata'] = 'FullDataPrev'; // FullDataPrev
                $State = myLog($State, "Проверили баров: " . ($i - $j - 1) . ". БПУ для т.3 (lcb3) = $j"); // lcb - level confirmation bar, БПУ - бар подвтерждающий уровень
            } else { // 1.2.2. Программа дошла до начальной точки графика или
                // 1.2.3. Цена проверила 300 баров, предшествующих т.3 , но уровень т.3 на этом участке не
                $State['param']['PREVdata'] = 'NoFullDataPrev'; // NoFullDataPrev
                $State = myLog($State, "Проверили баров: " . ($i - $j - 1) . ". БПУ для т.3 (lcb3) не найдена, начальный бар поиска подтверждающего экстремума = $j");
            }

            //1.3. поиск подтверждающего экстремума (в последующем потенциальной т.2)
            $A2Prev2_level = low($State['t3'], $v); // объявляем переменную для уровня подтверждающего экстремума (уровень начала предшествующего тренда) и пока что приравниваем её т.3 ВМП
            $is_A2Prev_found = false; // мы только что нашли БПУ т.3, поэтому начальная точка предшествующего тренда пока не найдена
            // $k = $j; // $j -  бар, начиная с которого ищем подтверждающий экстремум
            // while ($k < $i) // на участке от БПУт.3 или предполагаемого  до т.3
            for ($k = $j; $k < $i; $k++) // ищем подтверждающий т.3 экстремум (начало предшествующего тренда)
            {
                if (
                    high($k, $v) > $A2Prev2_level && // если хай бара больше уровня подтверждающего экстремума и...
                    is_extremum($k, not_v($v)) // являюется экстремумом, то...
                ) {
                    $A2Prev2_level = high($k, $v); // приравниваем уровень подтверждающего эктсремума (уровень начала предшествующего тренда) данному экстремуму
                    $State['A2Prev'] = $k; // нужно включить в список неприкасаемых элементов (?)
                    //    $State['t2'] = $k; //Е: временно, для отрисови (отладки) обозначаем как т2 //22222222222222222


                    for ($m = $k + 1; $m < $State['t3']; $m++) {
                        // Проверка абсолютности начальной точки предшествующего тренда. Программа осуществляет поиск бара с максимальной (если т.3 - low) или  минимальной (если т.3 - high) ценой на участке от кандидата в A2prev до т.3
                        if (high($m, $v) > $A2Prev2_level) continue 2; // если уровень подтверждающего для т.3 бара перебит,ищем другой подвтерждающий т.3 экстремум

                        //1.3.1.1. Программа осуществляет проверку на отсутствие между предполагаемой начальной точкой предш. тренда и т.3 экстремумов, равных т.3. 
                        if (low($m, $v) == $price_3) { // проверяем,чтобы на участке после бара - начала предшествуюего тренда не было экстремума,равного т.3
                            $State = myLog($State, "Найден более раниий экстремум ($m , $v) - кандидат в т.3 на уровне рассматриваемого кандадидата: $i - low($i, $v) на участке после начала предшествующего тренда"); //  было myLog_selected_bar \
                            continue 3;
                        }
                    }
                    $is_A2Prev_found = true; // найден подтверждающий экстремум для т.3
                }
                // $k++;
            }
            if ($is_A2Prev_found) {
                $state2 = clearState($State, "t3"); // создаем новую ветку - ищем новую т3 + стираем все ненужные ключи массива
                $state2['param'] = [];
                $state2['cnt'] = 0;
                $state2['curBar'] = $i - 1; // ищем вглубь, начиная с предыдущего бара
                if (isset($state2['flat_log'])) $state2['flat_log'] = []; // если был, то стираем лог
                $state2 = myLog($state2, "Ответвление на step_1 - ищем новую т3 начиная с " . $state2['curBar'] . " (" . $state2['v'] . ")");
                $state2['next_step'] = "A2_step_1"; // ответвление продолжнает обрабатывать новые т3
                $state2['split'] = $splitCnt++;
                $State2['param']['alt_old'] = $State['param']['alt_old'] ?? 0;
                $State['t3'] = $i;
                //$State=myLog($State,"Новый кандидат в т3($i)");
                // $State = myLog($State, "  найдена т.3 = $i");
                // $State['A2Prev'] = $k;
                $State['lcb3'] = $j;
                //  $State['t1'] = $j; // временно, для отрисовки и отладки --- 2222222222222
                $State = myLog($State, "(1->2) т3=$i A2Prev=" . $State['A2Prev'] . " lcb3=$j  + ветвление - создаем State для поиска очередной т3");
                //$State = myLog($State, "Найден подтверждающий экстремум для т.3 : " . $State['A2Prev'] . " переход к п.2 + ветвление - ищем другую т3"); // ЕЕ: было myLog_selected_bar + заменил $k на  $State['A2Prev']
                $State['curBar'] = $i + 2; //  t3+2 - ищем т5, начиная со следующего бара в п.2 (UPD. следующий не может быть т5 и не может пробить т3, поэтому +2 :)
                $State['next_step'] = 'A2_step_2';  // нашли подтверждающий экстремум - переход к п2 алгоритма
                // $cont = false; Е: - не нужно - и так выход
                return ([$State, $state2]); //продолжаем алгоритм с найденной т3 + расщепление : ищем новую т3, начиная от текущей т3 в прошлое
            } else $State = myLog($State, " Подтверждающий экстремум не найден между $j и $i ");
            // else return ([A2_next_T3($State)]); // если не найден подтверждающий экстремум - Е: тоже ошибка - зачем что-то возвращать, если не найден т2 - просто продолжаем цикл по %i дальше

        } // если бар проверяемый в качестве т.3 ВМП  является экстремумом, иначе выполняем перебор по $i дальше - БЫЛА ОШИБКА imho

        // return ([A2_next_T3($State)]); Е: зачем тут выход?
    } // проверили все бары до начала - т3 не найдена - выход
    $State = myLog($State, " прошли до начала графика - новых T3 не найдено, выход");
    $State['next_step'] = 'stop';
    return ($State);
}

function A2_step_2($State) // Пункт 2. ПОИСК ТОЧЕК 4 И 5.
{
    global $res; //, $lastT5fromT3; - уточнить для чего здесь нужна, если надо, раскомментирвоать

    $v = $State['v'];
    $curBar = $State['curBar'];
    // if (!isset($State['t5-'])) $A2_t5_last_level = 1000000000 // 't5-' - уровень отмененной т.5
    // else $A2_t5_last_level = low($State['t5-'], $v);
    $State = A2_myLog_start($State, "2");
    $check = checkUnique($State, "v,curBar,t3");
    if ($check) {
        $State = myLog($State, $check);
        $State['next_step'] = 'stop';
        return ($State);
    }
    for (
        $i = $curBar;
        $i < (nBars - 1)
            && $i <= ($State['t3'] + A2_BAR_T5_150) // расстояние от т.3 до анализируемого бара не должно превысить A2_BAR_T5_150
            && $i <= ($curBar + A2_BAR_T5_50); // кол-во проанализированных баров в этом пункте  не должно превысить A2_BAR_T5_50
        $i++
    ) {
        if (low($i, $v) < low($State['t3'], $v)) // проверка на непреодоление уровня т.3
        { // 2.1.	Если цена преодолела уровень т.3, программа ищет новую т.3 (в связи с Требованием №1).
            $State = myLog($State, "отмена t3 (" . $State['t3'] . ") - преодолен уровень t3 на баре $i");
            // $lastT3fromT1[$State['t1']] = 1000000000; // отсечка дальнейшего поиска т3 по данной т1
            $State['next_step'] = 'stop'; // закончили с этой т3
            return ($State); // Е: раньше искали новую Т3, но по новой концепии - просто стоп, так как не нашли потенциальную Т5. --- кeturn ([A2_next_T3($State)]);
        } else // 2.2.	Если Требование №1 выполняется для анализируемого бара, он проверяется на соответствие правилу N1 в качестве потенциальной точки 5 (далее - т.5).
            if (is_extremum($i, $v)) { // проверка анализизруемого бара в качестве экстремума - кандидата в т.5
                // 2.2.2. Если анализируемый бар определяется как экстремум по правилу N1
                if (low($i, $v) !=  low($State['t3'], $v)) { // 2.2.2.2. Если уровень т.3 не достигнут, анализируемый бар является потенциальной т.5., а программа переходит к пп.2.3.
                    //myLog_selected_bar($State, "($v) кандидат в t5: " . $i);
                    $State['t5'] = $i;
                    $State = myLog($State, "найден кандидат в т.5 =" . $i);
                    // 2.3. Поиск т.4
                    $State = A2_myLog_start($State, "2.3");
                    // определение участка, на котором может быть найден т.4 для данного кандидата в т.5
                    $price_5 = low($i, $v); // значение бара, которое будет проверяться в качестве т.5
                    $lcb5_found = -1;
                    for ($j = $i - 1; $j >= $State['t3']; $j--) { // ищем ближайший в прошлом (слева) от т.5 бар, пересекщий её уровень (БПУ для т.5)
                        // high возвращает обратный т.3 оператор, $price_5 возвращает значение рассматриваемой потенциальной т.5
                        if (
                            low($j, $v) < $price_5 //  low рассматриваемого бара меньше т.5 (low) 
                            // && high($j, $v) >= $price_5
                        ) {
                            $lcb5_found = $j;
                            break; // прерывает поиск, если подходящая точка найдена
                        }
                    }

                    if ($lcb5_found >= 0) { //  найдена lcb5
                        myLog_selected_bar($State, "Проверили баров: " . ($i - $lcb5_found - 1) . ". БПУ для т.5 (lcb5) =$lcb5_found"); // lcb5 - level-crossing bar for point 5
                        $A2_t4_level = low($State['t5'], $v);
                        $is_t4_found = false;

                        // for ($k = $lcb5_found; $k < $i; $k++) { // Программа осуществляет поиск бара с максимальной (если т.3 – low) или минимальной (если т.3 - high) ценой на промежутке от lcb5 до потенциальной т.5. Затем этот бар проверяется на «экстремальность» по правилу N1 в качестве потенциальной точки 4 (далее – т.4). Возможны 2 варианта:
                        //     if (high($k, $v) > $A2_t4_level) { // ищем абсолютный максимум/минимум
                        //         $A2_t4_level = high($k, $v);

                        //         if (is_extremum($k, not_v($v))) { // 2.3.1. Бар является экстремумом (в качестве потенциальной т.4). В этом случае найдена потенциальная т.4. Программа переходит к пункту 2.4.
                        //             $State['t4'] = $k;
                        //             $is_t4_found = true;
                        //             $State=myLog($State,"найден кандидат в т.4 = $k");
                        //         } //пункт обрабавается в цикле (2.3.2. Бар не является экстремумом (в качестве потенциальной т.4). В этом случае программа ищет другой кандидат на т.5 в соответствии с данным пунктом (т.е. по п.2.)
                        //     }
                        // }
                        $lcb5_found != $State['t3'] ? $look4 = $lcb5_found : $look4 = $lcb5_found + 1;
                        // for ($k = $lcb5_found; $k < $i; $k++) { // Программа осуществляет поиск бара с максимальной (если т.3 – low) или минимальной (если т.3 - high) ценой на промежутке от lcb5 до потенциальной т.5. Затем этот бар проверяется на «экстремальность» по правилу N1 в качестве потенциальной точки 4 (далее – т.4). Возможны 2 варианта:
                        for ($k = $look4; $k < $i; $k++) { // Программа осуществляет поиск бара с максимальной (если т.3 – low) или минимальной (если т.3 - high) ценой на промежутке от lcb5 до потенциальной т.5. Затем этот бар проверяется на «экстремальность» по правилу N1 в качестве потенциальной точки 4 (далее – т.4). Возможны 2 варианта:
                            if (high($k, $v) > $A2_t4_level) { // ищем уровень абсолютного максимума/минимума
                                $A2_t4_level = high($k, $v);
                            }
                        }

                        for ($k = $look4; $k < $i; $k++) { // Бар с максимальной (если т.3 – low) или минимальной (если т.3 - high) ценой на промежутке от lcb5 до потенциальной т.5. Затем этот бар проверяется на «экстремальность» по правилу N1 в качестве потенциальной точки 4 (далее – т.4). Возможны 2 варианта:
                            // for ($k = $lcb5_found; $k < $i; $k++) { // Бар с максимальной (если т.3 – low) или минимальной (если т.3 - high) ценой на промежутке от lcb5 до потенциальной т.5. Затем этот бар проверяется на «экстремальность» по правилу N1 в качестве потенциальной точки 4 (далее – т.4). Возможны 2 варианта:
                            if (
                                is_extremum($k, not_v($v))
                                && high($k, $v) == $A2_t4_level
                            ) { // 2.3.1. Бар является абсолютным экстремумом (в качестве потенциальной т.4). В этом случае найдена потенциальная т.4.

                                if (isset($State['t2'])) { // 2.3.1.1. Если данный пункт вызван в процессе поиска альтернативной модели модели (и уже определена т.2), программа осуществляет проверку ЛЦ на наличие пробоев ЛЦ на т.2-т.4
                                    $potentAL = (['bar' => $State['t2'], 'level' => high($State['t2'], $v), 'angle' => (high($k, $v) - high($State['t2'], $v)) / ($k - $State['t2'])]);
                                    for ($iii = $State['t2'] + 1; $iii < $k; $iii++) { // перебор баров от проверяемой потенциальной т.2 (не вклюяая), до т.4
                                        if (high($iii, $v) > lineLevel($potentAL, $iii)) { // 2.3.1.1.А. если пробивается ЛЦ, ищет новую т.5
                                            $State['curBar'] = $State['t5'] + 2;
                                            $State['next_step'] = 'A2_step_2';
                                            return ($State);
                                        }
                                    } // 2.3.1.1.В Лишние пересечения не найдены. Программа переходит к пункту 2.4.
                                }  //2.3.1.2. Пункт 2.3.1. вызван в процесс поиска базовой модели. Программа переходит к пункту 2.4.

                                // Программа переходит к пункту 2.4.
                                $State['t4'] = $k;
                                $is_t4_found = true;
                                $State = myLog($State, "найден кандидат в т.4 = $k");
                            } //пункт обрабавается в цикле (2.3.2. Бар не является экстремумом (в качестве потенциальной т.4). В этом случае программа ищет другой кандидат на т.5 в соответствии с данным пунктом (т.е. по п.2.)
                        }
                    } else { //  ...== false  // - просто движемся по циклу - ищем нового кандидата в т5
                        //$State=myLog($State,"Увы, lcb5 не найден");
                        myLog_selected_bar($State, "Проверили баров: " . ($i - $j - 1) . ". БПУ для т.5 (lcb5) не найдена, начальный бар поиска подтверждающего экстремума = $j");
                    }
                } // else {  // 2.2.2.1. Если уровень т.3 достигнут, программа анализирует следующий бар в соответствии с данным пунктом (т.е. с начала п.2 и далее по алгоритму).
                //   $State['curBar'] = $i + 1;
                //   $State['next_step'] = 'A2_step_2';
                //   return ([$State]);
                //}
            } // если экстремум
        //            else { // 2.2.1. Если анализируемый бар не является экстремумом по правилу N1 (в качестве потенциальной т.5), программа проверяет следующий бар с начала п.2 и далее по алгоритму.
        //                // $res['log'][] = " 2.2.1. Если анализируемый бар не является экстремумом по правилу N1";
        //                // $res['log'][] = "  если анализируемый бар не экстремум";
        //                $State['curBar'] = $i + 1;
        //                $State['next_step'] = 'A2_step_2';
        //                return ([$State]);
        //            }
        if (isset($is_t4_found) && $is_t4_found) {
            $State['next_step'] = 'A2_step_2_4';
            return ([$State]);
        }
    } // дошли до конца проверяемого участка
    $State = myLog($State, "дошли до конца проверяемого участка");
    if (!isset($is_t4_found) || !$is_t4_found) {
        $State = myLog($State, "новая т.3 (т.5 не найдена)");
        $State['next_step'] = 'stop';
        return ($State);
    }
}

function A2_step_2_4($State)
{ // Пункт 2.4. Проверка т.5 в режиме реального времени на потенциальную абсолютность
    global $res;
    $State = A2_myLog_start($State, "2.4");

    $v = $State['v'];
    $curBar = $State['t5'];
    $isLowerPriceBetween = false;

    $State = myLog($State, "запустили проверку т.5");

    for (
        $i = $State['t4'] + 1;
        $i < $State['t5']
            // && $i <= ($State['t3'] + A2_BAR_T5_150) // это здесь лишнее, уже есть в строке 330
        ;
        $i++
    )
        if (low($i, $v) <= low($curBar, $v)) {
            //            $isLowerPriceBetween = true; Е: убрал, упростил конструкцию - если не абсолют, то сразу выходим (на шаг_2)
            $State['curBar'] = $curBar + 1; //$State['curBar']++;
            $State['next_step'] = 'A2_step_2';
            $State = myLog($State, "новая т.5 не абсолют");
            return ($State);
            break;
        }
    // цикл пройден, значит, все ок - абсолют
    $State['next_step'] = 'A2_step_3';
    $State = myLog($State, "новая т.5 абсолют, переход на п.3");

    return ([$State]);
}

function A2_step_3($State)
{
    global $res;

    $v = $State['v'];
    $State = A2_myLog_start($State, "3");

    // Программа анализирует расположение потенциальной т.5 относительно бара потенциальной т.4.
    if (high($State['t5'], $v) >= high($State['t4'], $v)) {   // 3.1. Бар потенциальной т.5 достиг уровня т.4
        $State = myLog($State, "3.1. Бар потенциальной т.5 достиг уровня т.4.");
        $State['t4confirm'] = $State['t5']; // бар т.5 является баром подтверждения т.4
        $State['t4confirmed'] = true; // В этом случае точка 4 является подтвержденной,
        $State['t5confirmed'] = true; //точка 5 является подтвержденной
        //модель построена через т.5 абсолют (надо дописать этот параметр)
        $State['status']['Построена через t5 абсолют'] = 0; //2222222222222
        $State['$goto3_3_ext'] = false;
        $State['next_step'] = 'A2_step_3_3'; // программа переходит к пп.3.3.

        $State = myLog($State, " т.4 подтверждена баром т.5 (переходим к 3.3.)");

        return ([$State]);
    } else { // 3.2. Бар потенциальной т.5 не достиг уровня т.4
        $State = myLog($State, '3.2.Бар потенциальной т.5 не достиг уровня т.4');
        $State['curBar'] = $State['t5'] + 1; // следующий бар проверяется на достижение т.4
        $State['next_step'] = 'A2_step_3_2_1';

        $State = myLog($State, "т.5 не подвтерждает т.4 (переходим к 3.2.1.)");

        return ([$State]);
    }
}

function A2_step_3_2_1($State)
{ // бар(ы) после потенциальной т.5 проверяется на достижение уровня т.4 или новую т.5
    global $splitCnt;

    $v = $State['v'];
    $State = A2_myLog_start($State, "3.2.1");
    $curBar = $State['curBar'];
    if ($State['curBar'] >= nBars || ($State['curBar'] - $State['t5']) > BAR_50_321) {
        //JSON_log(["State"=>$State,"txt"=>"Ошибка - curBar=$curBar"],"testJSON___.json");
        $State = myLog($State, "Дошли до правой границы - stop (???)");
        $State['next_step'] = 'stop';
        return ($State);
    }
    $State['$goto3_3_ext'] = false;
    if (high($curBar, $v) >= high($State['t4'], $v)) { // 3.2.1.  Если рассматриваемый бар  достигает т.4
        $State = myLog($State, "3.2.1. После т.5 достигнут уровень т.4.");
        $State['conf_t4'] = $curBar;
        $State['t4confirm'] = $curBar; // рассматриваемый бар является баром подтверждения т.4
        $State['t4confirmed'] = true; // В этом случае точка 4 является подтвержденной,
        $State['t5confirmed'] = true; //точка 5 является подтвержденной
        // модель построена через т.5 абсолют (надо дописать этот параметр) (Е: пока сделал временно в виде статуса)
        $State['status']['Построена через t5 абсолют'] = 0; //22222222222
        // $State['next_step'] = 'A2_step_3_3_ext';
        $State['next_step'] = 'A2_step_3_3';
        $State['$goto3_3_ext'] = true;
        $State = myLog($State, "т.4 подтверждена баром $curBar (переходим к 3.3  с последующим переходом на 3.3.ext )");
        $State['curBar'] = $curBar + 1;
        return ([$State]);
    } else { // 3.2.2. рассматриваемый бар не достигает т.4

        // $State = myLog($State, "3.2.2. Данный бар расположенный позднее потенц. т.5 не достиг уровень т.4.");
        //$curBar = $State['curBar'] + 1; // программа проверяет следующий бар на преодоление т.5

        // -параллельно программа переходит к пп.3.3. (т.к. уже есть возможность отобразить модель через т.5 на графике. - Е: но только один раз сплит???
        if (($curBar - $State['t5']) == 1) { // делаем сплит, если так бар=следующий за т5
            $State2 = $State;
            $State2['split'] = $splitCnt;
            $State2['status'] = $State2['param'] = [];
            $State2['curBar'] = $curBar + 1;
            if (isset($State2['flat_log'])) $State2['flat_log'] = [];
            //  $State2 = clearState($State2, "t1,t2,t3,A2Prev,t3\',t4,t4',t5,t5'");  // Е: - t3\',t4',t5' - вроде лишние? да, и быть их еще здесь не должно??? тут вообще нужна очистка?  //222222222222
            $State2 = myLog($State2, "New State на 3.2.2 draw_flag (split_$splitCnt) пришли из split=" . $State['split']);
            $State = myLog($State, "Отпочковали новый State на 3.2.2 draw_flag (split_$splitCnt) - далее она на step_3_3");
            $State2['$goto3_3_ext'] = false;
            $State2['next_step'] = 'A2_step_3_3';
            $State2['draw_flag'] = true;
            $splitCnt++;
            $State2['mode'] = 'selected';
            $State2['param']['alt_old'] = $State['param']['alt_old'] ?? 0;
            // $State2['param']['alt_old'] = 0; // модель будет являеться основной, ветка только для отрисовки
        }

        if (low($curBar, $v) < low($State['t5'], $v)) { // 3.2.2.1. Если уровень т.5 преодолевается
            $State = myLog($State, "3.2.2.1. Уровень потенциальной т.5 преодолен баром $curBar до подтверждения т.4");
            $State['curBar'] = $curBar; // анализируемый бар рассматривается в качестве новой потенциальной т.5.
            $State['next_step'] = 'A2_step_2'; //Для этого программа обрабатывает данный бар по п.2 и  далее по алгоритму.
            $State = clearState($State, "t1,t2,t3,A2Prev");  // Е: надо проверить, добавил очистку при понижении уровня (шага алгоритма)
        } else { //3.2.2.2. Если уровень т.5 не преодолевается анализируемый бар проверяется на достижения уровня т.4. по п. 3.2.
            $State['curBar'] = $curBar + 1;
            $State = myLog($State, "3.2.2.2. Если уровень т.5 не преодолевается анализируемый бар проверяется на достижения уровня т.4. - снова на 3.2.1");
            $State['next_step'] = 'A2_step_3_2_1';
        }
        if (isset($State2)) return ([$State, $State2]);
        else return ($State);
    }
}

function A2_step_3_3($State)
{ // 3.3. ПОСТРОЕНИЕ ЛТ ВМП.
    global $res;

    //    $State = myLog($State, " ЗАГЛУШКА - дошли до step3_3"); //222222222

    $v = $State['v'];
    //$curBar = $State['curBar'];
    $State = A2_myLog_start($State, "3.3");

    $isT3s_found = false;
    //  if(!isset($State['t5']))$State=myLog($State,"tmp ERROR - не определен т5");
    for ($i = $State['t3']; $i < $State['t4']; $i++) { // перебор возмоных т.3/3'

        $isBroken = false;
        // ишем (след.стр) линию тренда T3'-T5
        $LT = ['bar' => $i, 'level' => low($i, $v), 'angle' => (low($State['t5'], $v) - low($i, $v)) / ($State['t5'] - $i)]; // линия тренда т.3 - т.5
        for ($j = $State['t3']; $j < $State['t5']; $j++) if ($j !== $i && $i !== $State['t4']) { // каждый бар между т.3 и т.5 проверяется на пробитие ЛТ.

            if (low($j, $v) < linelevel($LT, $j)) { // есть пробой ЛТ
                //$State = myLog($State, "3.3.1. Цена пробила  ЛТ на баре $j (i=$i)");
                $isBroken = true;
                break;
            }
        }
        if (!$isBroken) { // нет прробоя ЛТ, построенной от т.3
            $isT3s_found = $i;
            break;
        }
    }
    if ($isT3s_found) {
        if ($isT3s_found == $State['t3']) { // 3.3.2. ВМП построена через т.3 абсолют
            $State = myLog($State, "Модель через т.3");
            // $State['status']['tmp_Модель через т.3'] = 0; // для отладки 22222222222
        } else { // 3.3.1.1. Т.3' найдена, данная модель классифицируется, как построенная через т.3'.
            $State = myLog($State, "Модель через т.3'= $isT3s_found ");
            // $State['status']["tmp_Модель через т.3'"] = 0; // для отладки 22222222222
            $State['t3\''] = $isT3s_found;
        }
        // $State['next_step'] = 'A2_step_3_3_ext';
        //if (isset($State['$goto3_3_ext']) && $State['$goto3_3_ext']) {
        if (!isset($State['$goto3_3_ext'])) $State = myLog($State, "ERROR! - не определен параметр  goto3_3_ext - пришли из " . $res['info']['last_function_ok']);
        if ($State['$goto3_3_ext']) {
            $State['next_step'] = 'A2_step_3_3_ext';
            // $State = myLog($State, "'A2_step_3_3_ext'"); // для отладки 2222222222222222
            // $State['$cancelled_t5'] = $State['t5']; // уровень используемый в п.3.3.ext для отсева отмененных т.5". Здесь задаётся самое первичное значение, ещё до отсева.
            return ([$State]);
        } else {
            $State['next_step'] = 'A2_step_4';
            //$State = myLog($State, "'A2_step_4'"); // для отладки 2222222222222222
            // $State['$cancelled_t5'] = $State['t5']; // уровень используемый в п.3.3.ext для отсева отмененных т.5". Здесь задаётся самое первичное значение, ещё до отсева.
            return ([$State]);
        }
    } else { // 3.3.1.2. Т.3' не найдена. В этом случае программа ищет новые потенциальные т.5 и т.4 в соответствии с п.2.
        $State['curBar'] = $State['t5'] + 1;
        $State = myLog($State, "3.3.1.2. Т.3' не найдена - ищем новые потенциальные т.5 и т.4 в соответствии с п.2. curBar=" . $State['curBar']);
        $State = clearState($State, "t1,t2,t3,A2Prev");
        if (isset($State['draw_flag'])) {
            $State['next_step'] = 'stop';
            $State = myLog($State, "Временную модель из пункта 3_2_2 не удалось отрисовать- стоп");
        } else {
            $State['next_step'] = 'A2_step_2';
            $State = myLog($State, "переход на A2_step_2");
        }
        return ([$State]);
    }
}

function A2_step_3_3_ext($State)
{ // 3.3.extended  ПОСТРОЕНИЕ ЛТ ВМП ЧЕРЕЗ Т.5 И ПОСТРЕНИЕ ЛТ ВМП ЧЕРЕЗ Т.5"
    global $res;
    // ОБДУМАТЬ ДОБАВИТЬ УСЛОВИЕ, ЧТО ПУНКТ РАБОТАЕТ ТОЛЬКО ЕСЛИ Т.5 В ПРЕДЕЛАХ БАРА Т.4
    $v = $State['v'];
    // $curBar = $State['curBar'];
    $State = A2_myLog_start($State, "3.3.ext");

    // $State['$cancelled_t5ss'] = $State['t5'];
    if (!isset($State['$cancelled_t5ss'])) $State['$cancelled_t5ss'] = $State['t5']; // цикл идёт от бара, следующего за т.5 или за отмененной т.5". В обоих случаях одна и та же переменная
    //  Поиск т.5"
    $isT5ss_found = false;

    // if (!isset($State['t4confirm'])) $res['log'][] = "ERROR! - не определен t4confirm! пришли из " . $res['info']['last_function_ok'] . " split =" . $State['split']; // для отладки 222222222222222
    for ($i = $State['$cancelled_t5ss'] + 1; $i <= $State['t4confirm'] && $i <= (nBars - 2) && !$isT5ss_found; $i++) { // перебор возможных т.5", пока не найдем кандидат, который будем проверять на возможность простроения к нему ЛТ"
        $State = myLog($State, "Ведеём перебор баров в поисках кандидата в т.5\", потенциальная т.5\" = $i ,  ");    
        // Кандидат в т.5" должен удовлетворять следующим условиям:
        if (
            (low($i - 1, $v) < low($i, $v))
            && (low($i, $v) <= low($i + 1, $v))
            && (low($i, $v) > low($State['$cancelled_t5ss'], $v))
        ) {
            // проверка линии к т.5" на участке т.3/т.3" до т.5"
            // * По сути в этом месте идёт проверка пересечения ЛТ к потенциальной т.5" на участке т.5(включительно)-т.5"
            $t3_ = (isset($State['t3\''])) ? 't3\'' : 't3';
            // перебор баров на участке
            $isBroken_LT_tmp_ = false;
            // ишем (след.стр) линию тренда T3'-T5
            $LT_tmp_ = ['bar' => $State[$t3_], 'level' => low($State[$t3_], $v), 'angle' => (low($i, $v) - low($State[$t3_], $v)) / ($i - $State[$t3_])]; // линия тренда т.3/3' - кандидат в т.5"
            for ($r = $State[$t3_] + 1; $r < $i; $r++) { // каждый бар между т.3 и т.5 проверяется на пробитие ЛТ. //E: 20201001 - ОШИБКА: было for ($r = $State[$t3_] + 1; $i-1; $r++) {

                if (low($r, $v) < linelevel($LT_tmp_, $r)) { // есть пробой ЛТ
                    $isBroken_LT_tmp_ = true;
                    break;
                }
                // }
                // if ($isBroken_LT_tmp_) { // пробой ЛТ, построенной к потенциальной т.5" на учатске от т.3/3' до кандидата в т.5"
                //     break;
            }
            if (!$isBroken_LT_tmp_) {

                for ($k = $i + 1; $k <= $State['t4confirm']; $k++) { // перебор баров на участке после кандидата в т.5" до бара подтверждения т.4 (включительно)

                    if (low($k, $v) > low($i, $v)) { // ищем бар после кандидата в т.5", который будет строго выше бара кандидата в т.5"
                        // если текущий кандидат в т.5" ближе по уровню к т.4, чем предыдущий

                        // $isT5ss_found = $i;  // ! измененно 05.01.23
                        $isT5ss_found = true;
                        $State['t5"'] = $i;
                        $State = myLog($State, "Найден кандидат в t5\" - $i");
                        // break;
                        break 2; // ! измененно 05.01.23
                    } else if (low($k, $v) < low($i, $v)) break;
                }
            }
        }
    }  // выходим из этого цикла по флажку, когда выбран очередной кандидат в т.5" или когда закончен перебор баров до t4confirm

    $State['curBar'] = $i;

    // алгоритм поиска т.3"
    if ($isT5ss_found) { // если есть кандидат в т.5"

        if (isset($State['t3\''])) { // 13.1.1. Если анализируемая ВМП построена через т.3',

            for (($m = $State['t3\'']); $m >= $State['t3']; $m--) { // перебираем возможные т.3" вплоть до т.3
                // if ($State['next_step'] == 'A2_step_13_2') break; // лишнее
                // $LTss = (['bar' => $State[$m], 'level' => low($State[$m], $v), 'angle' => (low($i, $v) - low($State[$t3_], $v)) / ($i - $State[$t3_])]);
                $LTss = (['bar' => $m, 'level' => low($m, $v), 'angle' => (low($State['t5"'], $v) - low($m, $v)) / ($State['t5"'] - $m)]);
                $isBroken3_3ss = false;
                // for ($l = $State['t3']; $l < $m; $l++)  { // проверяем на участке от т.3 (включая) до кандидата в т.3" (не включая) наличие пробоев
                // for ($l = $State['t3'] + 1; $l < $m; $l++) { // проверяем на участке от т.3 (не включая) до кандидата в т.3" (не включая) наличие пробоев // ! измененно 05.01.23
                for ($l = $State['t3']; $l < $State['t5"']; $l++) { // проверяем на участке от т.3 (не включая) до кандидата в т.5" (не включая) наличие пробоев 
                    // if (low($l, $v) < linelevel($LTss, $l) ) { // если пробой есть // ! измененно 05.01.23
                    if (low($l, $v) < linelevel($LTss, $l) && $l != $m ) { // если пробой есть
                        $State = myLog($State, "Пробой ЛТ через кандидата в т.3\" = $m баром $l - ищем новую т.3\"");
                        $isBroken3_3ss = $l;
                        break;
                    }
                    // else { // найдена т.3"
                    //     $State['t3"'] = $m;// перенесено вниз
                    // }
                }
                // if (!$isBroken3_3ss) {
                //     // for ($s=$isT5ss_found+1; $s = $State['t4confirm']; $s++)

                // }

                if (!$isBroken3_3ss) { // Если пробоя нет - 13.1.1.2.1.  подходящая т.3" найдена
                    // (может совпадать не только с т.3', но и с т.3)

                    // 13.1.1.1 осуществляется проверка на пересечение ЛЦ" баром, следующим за т.5"
                    if (low(($State['t5"'] + 1), $v) < linelevel($LTss, ($State['t5"'] + 1))) { //13.1.1.1.А. проверка ЛТ" на баре, следующем после т.5", если оказвывается, что есть пересечение, т.5" ищется дальше
                        $State = myLog(
                            $State,
                            "Кандидат в т.5\" = " . $State['t5"'] . "- не является касательной"
                        );
                        $State['$cancelled_t5ss'] = $State['t5"'];
                        unset($State['t5"']);
                        $State['next_step'] = 'A2_step_3_3_ext';
                        return ([$State]);
                    }

                    $State['t3"'] = $m; // 13.1.1.1.Б. программа переходит к п. 13.2.
                    // if ($State['t3\''] == $m) { // если т.3' совпадает с т.3"
                    if ($State['t3\''] == $State['t3"']) { // если т.3' совпадает с т.3"
                        $State = myLog($State, "ЛТ ВМП к т.5\" построена через т.3' ($m)");
                    } else { // найдена т.3"
                        $State = myLog($State, "ЛТ ВМП к т.5\" построена через т.3\" ($m)");
                    }
                    $State['next_step'] = 'A2_step_13_2'; // алгоритм переходит к пп.13.2.
                    return ([$State]);
                    // break;
                }
                // else
                //{ // 13.1.1.2.2. Если подходящая т.3" не найдена, проводится повторный поиск кандидата в т.5" по пп.13.1 , но при этом новый кандидат должен быть уже дальше от т.4, чем ранее отброшенные.
                //     $State['$cancelled_t5ss'] = $State['t5"'];
                //     $State['next_step'] = 'A2_step_3_3_ext';
                // return ([$State]);
                // }
            } // прошли все потенциальные т.3"

            if (!isset($State['t3"'])) { // 13.1.1.2. Если подходящая т.3" не найдена, проводится повторный поиск кандидата в т.5" по пп.13.1 , но при этом новый кандидат должен быть уже дальше от т.4, чем ранее отброшенные.

                if ($State['curBar'] == $State['t4confirm']) { // если в цикле поиска т.5" дошли до t4confirm, то нет смысла перезапускать поиск т.5"
                    unset($State['t5"']);
                    $State['next_step'] =  'A2_step_4'; // переходим к п.4
                } else {
                    $State['$cancelled_t5ss'] = $State['t5"'];
                    unset($State['t5"']);
                    $State['next_step'] = 'A2_step_3_3_ext';
                    return ([$State]);
                }
            }
        } else { //13.1.2. Если анализируемая ВМП построена через т.3,
            $LT = (['bar' => $State['t3'], 'level' => low($State['t3'], $v), 'angle' => (low($State['t5"'], $v) - low($State['t3'], $v)) / ($State['t5"'] - $State['t3'])]);
            // 13.1.2.А. (аналог 13.1.1.А) осуществляется проверка на пересечение ЛТ" баром, следующим за т.5"
            if (low(($State['t5"'] + 1), $v) < linelevel($LT, ($State['t5"'] + 1))) { // проверка ЛТ" на баре, следующем после т.5", если оказвывается, что есть пересечение, т.5" ищется дальше
                $State = myLog(
                    $State,
                    "Кандидат в т.5\" = " . $State['t5"'] . "- не является касательной, ищем новую т.5 (бар "
                    //. $State['t5"']+1 ." =" . low(($State['t5"']+1), $v) . " пересекает линию " . linelevel( $LT, ($State['t5"']+1)) . "от бара т.3\"= " . $State['t3'] . "к бару т.5\"=" . $State['t5"']
                );
                $State['$cancelled_t5ss'] = $State['t5"'];
                unset($State['t5"']);
                $State['next_step'] = 'A2_step_3_3_ext';
                return ([$State]);
            }     //  13.1.2.Б. алгоритм переходит к п.13.2.
            // $isBroken3_3ss = false;
            $State['next_step'] = 'A2_step_13_2';
            return ([$State]);
        }
    } else { // 13.2.3. Если т.5" не найдена, Программа переходит к п.4.
        $State['next_step'] = 'A2_step_4';
        return ([$State]);
    }
}

function A2_step_13_2($State)
{
    global $res;
    $v = $State['v'];
    $State = A2_myLog_start($State, "13.2");
    $LT_ss = A2_LT_ss($State);
    for ($t = $State['t5']; $t < $State['t5"']; $t++) { // 13.2. ЛТ" проверяется на пересечения ценой на участке между т.5 (включительно) и потенциальной т.5" (далее участок 5-5").
        // $State = myLog($State, "Отбрасываем т.5\" в 13_2 т.к. есть пересечение на т.5-т.5\" баром $t - ищем новую т.5\" или идём на п.4");
        if ($t < linelevel($LT_ss, $t)) { // 13.2.1.	Если пересечение есть, то эта 5" отсеивается.
            if ($State['curBar'] == $State['t4confirm']) { // если в цикле поиска т.5" дошли до t4confirm, то нет смысла перезапускать поиск т.5"
                unset($State['t5"']);
                $State['next_step'] =  'A2_step_4'; // переходим к п.4
                break;
            } else {
                $State = myLog($State, "Отбрасываем т.5\" в 13_2 т.к. есть пересечение на т.5-т.5\" баром $t - ищем новую т.5\" или идём на п.4");
                // $State['$cancelled_t5ss'] = $t; // при этом новый кандидат должен быть уже дальше от т.4, чем ранее отброшенные.
                $State['$cancelled_t5ss'] = $State['t5"']; // при этом новый кандидат должен быть уже дальше от т.4, чем ранее отброшенные.
                unset($State['t5"']);
                // $State['next_step'] = 'A2_step_3_3_ext'; // Проводится повторный поиск кандидата в т.5"
                $State['next_step'] = 'A2_step_3_3_ext'; // Проводится повторный поиск кандидата в т.5"
                return ([$State]);
            }
        } else { // 13.2.2.	Если пересечения ЛТ" на участке 5-5" нет, то значит т.5" найдена
            $State['next_step'] = 'A2_step_4';
            // надо добавить добавление значения параметра EAM5"
            return ([$State]);
        }
    } // 13.2.3. Если т.5" не найдена, Программа переходит к п.4.
    $State['next_step'] = 'A2_step_4';
    return ([$State]);
}

function A2_step_4($State)
{ // 4.ПОИСК ПОТЕНЦИАЛЬНЫХ БЛОКОВ ОСНОВАНИЙ.
    global $res;

    //     $State = A2_myLog_start($State, "4");
    //     $State = myLog($State, " ЗАГЛУШКА - дошли до step 4, фиксируем пока то что есть"); //222222222
    //     $State = A2_fix_model($State, "TMP Модель на старте step_4");
    //     $State['next_step'] = 'stop';
    //     return ([$State]);

    // ! Added 09/04/22 
    // 4.0. 
    if (isset($State['t2'])) { // * Incase we got point 2 already set by this moment we are in the alternative  model searching branch  
        // 4.0.1. Point 2 is already set by this moment- it's the alternative  model searching branch. Going to A2_step_6
        $State = myLog($State, "point 2 =" . $State['t2'] . "already set by this moment- it's the alternative  model searching branch. Going to A2_step_6");
        $State['next_step'] = 'A2_step_6';
        return ($State);
    } 
    //4.0.2. go to 4.1. 
    // 4.1.
    $v = $State['v'];
    $State = A2_myLog_start($State, "4");
    if (!isset($State['A2Prev'])) $State = myLog($State, "ERROR! - почему то не определен A2Prev - пришли из " . $res['info']['last_function_ok']);
    unset($State['p12candidates']); //  Е: не уверен, что актуально - вставил на всякий случай
    // $isP2candidatefound = false;
    for ( // поиск кандидатов в т.2
        $i = $State['t3'] - 1;
        $i > 0;
        // пока не произойдет отменяющее поиск событие 4.2.
        //&& $i > $State['A2Prev'] // ищем т.2 не далее (предполагаемого) начального бара предыдущего тренда
        //&& $i > ($State['t3'] - (($State['t4'] - $State['t3']) * P23to34)) // не далее бара, который находится на расстоянии (по времени) от т.3 большем, либо равном X*(расстояние от т.3 до т.4), где x – задаваемый в настройках параметр (по умолчанию равен 3).
        //глубина поиска т.2
        //&& $i > ($State['t3'] - BAR_50); // ищем т.2 не далее 50 баров до т.3
        $i--
    ) {
        // вначале проверяем на превышение глубины поиска - далее 3 проверки
        // проверка на достижение (предполагаемого) начального бара предыдущего тренда
        if ($i <= $State['A2Prev']) {
            $State = myLog($State, "Достигли (предполагаемого) начального бара предыдущего тренда A2Prev=" . $State['A2Prev']);
            break;
        }
        if ($i <= ($State['t3'] - (($State['t4'] - $State['t3']) * P23to34))) {
            $State = myLog($State, "Достигли бара ($i), который находится на расстоянии (по времени) от т.3 большем, либо равном X*(расстояние от т.3 до т.4) где X=" . P23to34);
            break;
        }
        if ($i <= ($State['t3'] - BAR_50)) {
            $State = myLog($State, "Достигли глубины поиска BAR_50=" . BAR_50 . " на баре=$i");
            break;
        }
        if ( // отменяющее поиск событие  4.3.
            high($i, $v) >= high($State['t4'], $v) // 4.3. Проверка дошла до бара, который пересекает уровень предполагаемой точки 4
            // СТРОКА НИЖЕ ЗДЕСЬ НЕ НУЖНА, Т.К. МЫ ВЫШЕ ВВЕЛИ ПРОВВЕРКУ "не далее (предполагаемого) начального бара предыдущего тренда
        ) { // прекращаем поиск т.2
            $State = myLog($State, "При поиске т.2 ушли за уровень т.4");
            break;
        }
        // все проверки пройдены
        // $State=myLog($State,"TMP Все проверки пройдены для i=$i");
        if (is_extremum($i, not_v($v))) { // 4.1.0. Найден экстремум кандидат в т.2.
            // $State=myLog($State,"TMP найден экстремум для i=$i");
            // осуществляется поиск т.1 подтверждающего экстремума для потенциальной т.2
            unset($P1candidate);
            for ( // на участке до т.2 и до не далее 50 баров в прошлое до т.2
                $j = $i - 1;
                $j > 0
                    && $j > ($i - BAR_50)
                    && $j >= $State['A2Prev'];
                $j--
            ) { // ищем бар, пересекающий уровень потенциальной т.2
                if (high($j, $v) > high($i, $v)) { // преодолевается уровень потенциальной т.2

                    //поиск потенциальной т.1
                    for ($k = $j; $k < $i; $k++)  if (is_extremum($k, $v)) { // если найдена т.1
                        if (isset($P1candidate)) {
                            if (low($k, $v) < low($P1candidate, $v)) {
                                // $P2candidate = $i;
                                $P1candidate = $k;
                                // $confirmP2 = $j; // бар, подтверждающий (пересекший уровень) т.2
                            }
                        } else {
                            $P2candidate = $i;
                            $P1candidate = $k;
                            $confirmP2 = $j; // бар, подтверждающий (пересекший уровень) т.2
                        }
                    }

                    if (isset($P1candidate)) { // формируем подмассив из потенциальных т.2 + т.1
                        $State['p12candidates'][] = [$P2candidate, $P1candidate, $confirmP2];
                        // $State = myLog($State, "Новый БО P2candidte=$P2candidate P1candidate=$P1candidate confirmP2=$confirmP2");
                    }
                    break; // завершаем поиск подвтерждающего экстремума
                }
            } // завершен поиск БПУ (bcl2)
        } // рассматриваемый бар не является экстремумом (не годится в кандидаты в т.2)
    } // закончили поверку всех потенциальных экстремомв в т.2 на подходящем участке

    // if (isset($State['p12candidates']) == true) { //  4.2.1.(4.3.1.) Найдена одна или несколько пар потенциальных т.2 и т.1.
    if (isset($State['p12candidates'])) { //  4.2.1.(4.3.1.) Найдена одна или несколько пар потенциальных т.2 и т.1.
        $State['next_step'] = 'A2_step_5';
        $State = myLog($State, "Найден(ы) кандидат(ы) в БО - идем на  'A2_step_5' ");
        foreach ($State['p12candidates'] as $pk => $bo) {
            $t2Candidate = $bo[0];
            $State = myLog($State, "Кандидат в т.2 = . $t2Candidate . ");
        }
        return ([$State]);
    } else { // нет подходящих т.2 для данной т.5
        $curBar = $State['curBar'] = $State['t5'] + 2;
        if (isset($State['draw_flag'])) {
            $State['next_step'] = 'stop';
            $State = myLog($State, "Временную модель отрисовать не удалось - stop");
        } else   $State['next_step'] = 'A2_step_2'; // программа ищет следующую потенциальную т.5 и т.4 в соответствии с п.2.
        $State = myLog($State, "Не найден(ы) кандидат(ы) в БО  - next_step=" . $State['next_step'] . " curBar = $curBar  ");
        $State = clearState($State, "t3,A2Prev");
        return ([$State]);
    }
}


function A2_step_5($State)
{ // 5. ПОИСК ПРЕСУППОЗИЦИИ
    global $res;
    //
    $State = A2_myLog_start($State, "5");
    //    $State = myLog($State, " ЗАГЛУШКА - дошли до step 5, фиксируем пока то что есть"); //222222222
    //    $State = A2_fix_model($State, "TMP Модель на старте step_5");
    //    $State['next_step'] = 'stop';
    //    return ([$State]);

    $v = $State['v'];

    // foreach ($State['p12candidates'] as list($i, $P1candidate, $confirmP2)) { // где $i - это т.2 ВМП, $P1candidate - это т.1 ВМП
    foreach ($State['p12candidates'] as $pk => $bo) {
        $p2Candidate = $bo[0]; // - это т.2 ВМП,
        $p1Candidate = $bo[1]; //$P1candidate - это т.1 ВМП
        $confirmP2 = $bo[2];
        $State = myLog($State, " Проверяем БО № " . ($pk + 1) . " из " . count($State['p12candidates']) . " - цикл с " . ($p2Candidate + 1) . " по " . $State['t3']);
        //5.1. Программа поочередно проверяет бары слева направо (в будущее) от потенциальной т.1п (или от другого указанного в алгоритме бара при повторном применении пункта) до т.3 ВМП (не включая)...
        for ($t3pSearch = $p2Candidate + 1; $t3pSearch < $State['t3']; $t3pSearch++) { // поиск точки т.3п ($l)
            //$State=myLog($State,"проверяем на экстремальность бар l=$l");
            if (
                is_extremum($t3pSearch, not_v($v)) //...на экстремальность по правилу N1 в качестве точки 3 Пресуппозиции (далее т.3п).
                && high($t3pSearch, $v) > high($p2Candidate, $v) // ...Если т.1п является high, то т.3п должна лежать выше т.1п.
            ) { // 5.1.2.  Как только потенциальная т.3п найдена, происходит поиск точки 2 Пресуппозиции (далее т.2п),
                $State = myLog($State, "5.1.2 потенциальная т3п=$t3pSearch ('экстремум " . not_v($v) . " ')");
                $isAbsP2p = high($p2Candidate, $v); // приравниваем уровень последнего абсолютного кандидата в т.2п уровню т.1п
                $t2p_candidate = false;
                for ($t2pSearch = $p2Candidate + 1; $t2pSearch < $t3pSearch; $t2pSearch++)  // поиск т.2п ($m) между т.1п и т.3п.
                    if (is_extremum($t2pSearch, $v)) {
                        //  как бара с максимальной/минимальной ценой на промежутке от т.1п до т.3п (далее участок 1п-3п), поэтому...
                        if (low($t2pSearch, $v) < $isAbsP2p) { // если перебивает предыдущий кандидат в т.2п, то это новый кандадидат в т.2п
                            $isAbsP2p = low($t2pSearch, $v);
                            $t2p_candidate = $t2pSearch; // Е: добавил - запоминаем номер бара т2п - в первоначальной версии была путаница и номер бара и цена одной переменной обозначалась
                            $State = myLog($State, " Новый кандидат в т2п - $t2pSearch (на участке с " . ($p2Candidate + 1) . " по " . ($t3pSearch - 1) . ")");
                        }
                    }
                // 5.1.2.1. Бар является абсолютным экстремумом. В этом случае найдена потенциальная т.2п, и программа переходит к пп.5.2.
                if ($t2p_candidate) { // если был найден т.2п
                    //5.2. Программа строит линию от т.1п к т.3п и проверяет её на наличие лишних пересечений ценой на участке от т.1п. до т.3 ВМП (включительно).
                    $LTp = ['bar' => $p2Candidate, 'level' => high($p2Candidate, $v), 'angle' => (high($t3pSearch, $v) - high($p2Candidate, $v)) / ($t3pSearch - $p2Candidate)]; // ЛТ пресуппозиции //Е: было  high($State[$i]
                    // $LTp = ['bar' => $t2p_candidate, 'level' => high($t2p_candidate, $v), 'angle' => (high($t3pSearch, $v) - high($t2p_candidate, $v)) / ($t3pSearch - $t2p_candidate)]; // ЛТ пресуппозиции //Е: было  high($State[$i]
                    $isbrokenLTp = false;
                    for ($z = $p2Candidate + 1; $z < $State['t3']; $z++) if ($z !== $t3pSearch)  // на участке от т.1п (т.2 ВМП) до т.3 ВМП  проверяем ЛТп на пробои   // Е: $i+1, $i!==$l
                        // for ($z = $t2p_candidate + 1; $z < $State['t3']; $z++) if ($z !== $t3pSearch)  // на участке от т.1п (т.2 ВМП) до т.3 ВМП  проверяем ЛТп на пробои   // Е: $i+1, $i!==$l
                        if (high($z, $v) > lineLevel($LTp, $z)) { //5.2.1. если ЛТп пробита  // E: была ошибка: if ($z > $LTp)
                            $isbrokenLTp = true;
                            $State = myLog($State, " Увы, пробой ЛТп на баре $z");
                            break;
                        }
                }

                // 5.3. Программа ищет потенциальную точку 4 Пресуппозиции (т.4п)
                if ($t2p_candidate && !$isbrokenLTp) { // если через рассматриваемую потенциальную т.3п ($l) строится ЛТп без пробоев
                    $State = myLog($State, "5.3 кандидаты: т1п=$p2Candidate, т2п=$t2p_candidate т3п=$t3pSearch ->Ищем потенциальнyю т4п");
                    $isAbsP4p = low($t2p_candidate, $v); // приравниваем уровень последнего абсолютного кандидата в т.4п уровню т.2п // Е: было   $isAbsP4p = low($isAbsP2p, $v); - это не номер бара а уровень
                    //$t4p_candadate=false; // E: сделал аналогичсно с $t2p_candidate
                    for ($t4pSearch = $t3pSearch + 1; $t4pSearch <= $State['t3']; $t4pSearch++) { // 5.3. поиск т.4п ($g) на участке от т.3п (не включая), до т.3 ВМП(включая)
                        // $State = myLog($State, "TMP 5.3 цикл по t4pSearch=$t4pSearch");
                        //  $isExtremumt4pFound=false;
                        $t4p_candadate = false;
                        if (low($t4pSearch, $v) < $isAbsP4p && is_extremum($t4pSearch, $v)) {
                            //    $isExtremumt4pFound=true;
                            $isAbsP4p = low($t4pSearch, $v); // т.4п является реперным
                            $State = myLog($State, "нашли экстремум (кандидат в т4п) = $t4pSearch");
                            $t4p_candadate = false;
                            $confirmP4p = false; // Е: не обнулялась Ошибка???
                            if ($t4pSearch != $State['t3']) { //5.3.Б. Если потенциальная т.4п не совпадает с т.3 ВМП (т.е. лежит перед ней), то программа ищет на участке от потенциальной т.4п (не включая) до бара, на котором цена повторно достигла значения потенциальной т.4п (включительно) экстремум, который противонаправлен экстремуму т.4п.
                                $State = myLog($State, "т4п не совпала с т3ВМП - ищем экстремум на участке от потенц т4п до пересечения уровня т4п");
                                for ($t4pReachedSearch = $t4pSearch + 1; $t4pReachedSearch <= $State['t3']; $t4pReachedSearch++)  // поиск бара, на котором будет повторно достигнут уровень потенциальной т.4п
                                    if (low($t4pReachedSearch, $v) <= low($t4pSearch, $v)) {
                                        $confirmP4p = $t4pReachedSearch; // Е: была неиспользуемая переменная
                                        break;
                                    }
                                if (!$confirmP4p) $State = myLog($State, "ERROR1 - нет подтрверждения t4p ! t4pSearch=$t4pSearch");
                                // E: - видимо надо вставить условие успешности прошлого цикла - поиска экстремуму? - добавил слел строчку-проверку : if($confirmP4p)

                                if ($confirmP4p) // по идее, всегда найден
                                    for ($extremumContra_t4pSearch = $t4pSearch + 1; $extremumContra_t4pSearch < $confirmP4p; $extremumContra_t4pSearch++)  // Затем программа ищет экстремум, который противонаправлен экстремуму т.4п. Возможны 2 варианта:...
                                        if (is_extremum($extremumContra_t4pSearch, not_v($v))) {
                                            //$isAbsP4p = low($t4pSearch, $v); // т.4п является реперным -УБРАЛИ 09.09.2020 при онлайн отладке
                                            $t4p_candadate = $t4pSearch;
                                            $State = myLog($State, "т.4п является реперным - бар=$t4pSearch подтвержден экстремумом $extremumContra_t4pSearch ");
                                        }
                            } else {
                                //else { // 5.3.А. Если потенциальная т.4п совпадает с т.3 ВМП, т.4п подтверждена, программа переходит к пп.5.3.1. // Е: Ошибка? след оператор не выполнялся - убрал else
                                $t4p_candadate = $State['t3'];
                                //  break;
                            }
                        } //else { // 5.3.А. Если потенциальная т.4п совпадает с т.3 ВМП, т.4п подтверждена, программа переходит к пп.5.3.1. // Е: Ошибка? след оператор не выполнялся - убрал else
                        //  $isAbsP4p = low($g, $v);
                        //  break;
                        //} // Е:!!!!!! Проветрить - но этот else был явно левый - может просто break нужен???

                        if ($t4p_candadate === false) { // если это не был кандидат в т4п либо он не подтвердился противонаправленным экстремумом, то ищем следующий
                            //   $State=myLog($State," isAbsP4p ($isAbsP4p) == isAbsP2p ($isAbsP2p)  -> continue");
                            continue; // 5.3.Б.2. Если противонаправленный экстремум не найден, то т.4п отменена, а программа ищет новую потенциальную т.4п. для чего обрабатывает бар, следующий за отмененной т.4п с начала пп.5.3.
                        }

                        //  if ($isAbsP4p != $isAbsP2p) { // 5.3.Б.1. Если противонаправленный экстремум найден, то Программа переходит к пп.5.3.1. // Е: зачем эта проверка - в предыдущем if мы делаем continue?
                        // 5.3.1.
                        //$ALp = (['bar' => $isAbsP2p, 'level' => low($isAbsP2p, $v), 'angle' => (low($isAbsP4p, $v) - low($State[$isAbsP2p], $v)) / ($isAbsP4p - $isAbsP2p)]);  // Е: использовали цену вместо номера бара:  $ALp = (['bar' => $isAbsP2p,
                        $ALp = (['bar' => $t2p_candidate, 'level' => $isAbsP2p, 'angle' => ($isAbsP4p - $isAbsP2p) / ($t4p_candadate - $t2p_candidate)]);
                        $State = myLog($State, " Определили ALp bar=$t2p_candidate level=$isAbsP2p angle=" . ($isAbsP4p - $isAbsP2p) / ($t4p_candadate - $t2p_candidate));
                        $isbrokenALp = false; // ЛЦп не пробита - Е: вначале ставим false
                        for ($ii = $p2Candidate + 1; $ii <= $State['t3']; $ii++)  // и проверяет данную линию на отсутствие лишних пересечений с ценой на участке от т.1п (не включая) до т.3 ВМП (включая).
                            if (low($ii, $v) < lineLevel($ALp, $ii)) { // если ЛЦп пробита // Е: было if ($ii > $ALp) {
                                $isbrokenALp = true;
                                $State = myLog($State, " ЛЦп пробита на баре $ii");
                                break; // найден пробой ЛЦп пресуппозиции, прекращаем проверку данной линии
                            }
                        // $isAbsP3p = true;
                        $isAbsP3p = false;
                        if (!$isbrokenALp) { // 5.3.1.2. Если лишние пересечения не найдены, алгоритм переходит к п. 5.3.2.
                            // 5.3.2. Ядро проверяет бар потенциальной т.3п на абсолютность.
                            $State = myLog($State, " ALp не пробита");
                            $isAbsP3p = true;
                            for ($o = $t3pSearch + 1; $o < $t4p_candadate; $o++) { // Уровень т.3п не должен преодолеваться ценой на участке между т.3п. и потенциальной т.4п (не включая) // Е: заменил $isAbsP4p на  $t4p_candadate
                                if (high($o, $v) > high($t3pSearch, $v)) { // 5.3.2.1. Если уровень т.3п преодолевается, то данная потенциальная т.3п отбрасывается, а ядро ищет новую т.3п, для чего обрабатывает следующий за отброшенной потенциальной т.3п бар по пп.5.1. и далее по алгоритму.
                                    $State = myLog($State, " Пробой уровня t3p=" . high($t3pSearch, $v) . " на баре($o) - до бара t4p=$t4p_candadate");
                                    // $isAbsP3p = false; // это строка видимо лишняя
                                    break 2;
                                }
                            }
                        }
                        // if (isset($isAbsP3p)&&(!$isAbsP3p)) break; // 5.3.2.1. Если уровень т.3п преодолевается, то данная потенциальная т.3п отбрасывается, а ядро ищет новую т.3п, для чего обрабатывает следующий за отброшенной потенциальной т.3п бар по пп.5.1. и далее по алгоритму.
                        //                        $State=myLog($State," TMP info: isAbsP3p=$isAbsP3p ");
                        //                        $State=mylog($State,'low($p2Candidate, $v) < low($t3pSearch, $v)='.(low($p2Candidate, $v) < low($t3pSearch, $v)));
                        //                        $State=mylog($State,'high($p2Candidate, $v) > high($t2p_candidate, $v)='.(high($p2Candidate, $v) > high($t2p_candidate, $v)));
                        //                        $State=mylog($State,"$t2p_candidate $p2Candidate".'low($t2p_candidate, $v) < low($p2Candidate, $v)='.(low($t2p_candidate, $v) < low($p2Candidate, $v)));
                        //                        $State=mylog($State,'low($t2p_candidate, $v) < low($t3pSearch, $v)='.(low($t2p_candidate, $v) < low($t3pSearch, $v)));
                        //  $State=mylog($State,"$p1Candidate ".'high($p1Candidate, $v)='.high($p1Candidate, $v));
                        //  $State=mylog($State,"$t2pSearch ".'high($t2pSearch, $v)='.high($t2pSearch, $v));
                        if (
                            !$isbrokenALp
                            && isset($isAbsP3p) && $isAbsP3p == true // Е: также не определена переменная, если предыдущий блок не отработал, добавил isset
                            // 5.4. Пресуппозиции проходят следующие проверки:
                            && low($p2Candidate, $v) < low($t3pSearch, $v) // т.1п выходит за т.3п.
                            && high($p2Candidate, $v) > high($t2p_candidate, $v) // т.1п выходит за т.2п.
                            && low($t2p_candidate, $v) < low($p2Candidate, $v) // т.2п выходит за т.1п.
                            && low($t2p_candidate, $v) < low($t3pSearch, $v) // т.2п выходит за т.3п.
                            // Б. – расстояние по уровням между т.1 и т.2 (далее - ранг 12) должен быть не менее значения Минимального расстояния между т.1 и т.2 Пресуппозиции, которое задается от расстояния между уровнями т.4  и т.5  ВМП (это - ранг 45).
                            && abs(high($p2Candidate, $v) - low($t2p_candidate, $v)) >= abs(high($State['t4'], $v) - low($State['t5'], $v)) * P12
                        ) { // Если все проверки пройдены успешно, то Пресуппозиция найдена.
                            if (!isset($State['Presupp'])) $State['Presupp'] = [];
                            $State = myLog($State, "5.4. Найдена Пресуппозиция № " . (count($State['Presupp']) + 1));
                            $State['Presupp'][] = ['t1p' => $p2Candidate, 't3p' => $t3pSearch, 't2p' => $t2p_candidate, 't4p' => $t4p_candadate, 'confirmT1p' => $confirmP2];
                        }
                    } // завершен поиск потенциальной т.4п (до проверки ЛЦ Пресуппозиции через эту т.4п)
                } //ЛТп без пробоя и найден т2п
            } //бар не подходит в т3п - идем дельше про циклу $l
        } // 5.3.1.3. Если программа проверила все бары на участке от т.3п до т.3 ВМП (включительно) и не нашла такую т.4п, через которую можно построить линию от т.2п к т.4п таким образом, чтобы на ней не было лишних точек, то алгоритм переходит к п. 5.X.
        // ПО СУТИ ПРОСТО ПЕРЕЗАПУСК ЦИКЛА  // E5: я так понял, что пункт 5.X лишний ? мы просто к следующему БО переходим
    } // перебо всех БО (foreach)
    $State['next_step'] = 'A2_step_6';
    return ($State);
}

function A2_step_6($State)
{ // ПРОВЕРКА НА ПЕРЕСЕЧЕНИЕ ЛЦ. ПРОВЕРКА НА СХОДИМОСТЬ ЛЦ И ЛТ.
    $State = A2_myLog_start($State, "6");
    $v = $State['v'];

    // ! Added 09/04/22
    // 6 alfa. Checking if point 2 is already set
    if (isset($State['t2'])) { // * Incase we got point 2 already set by this moment we are in the alternative  model searching branch  
        $State = myLog($State, "point 2 =" . $State['t2'] . "already set by this moment- it's the alternative  model searching branch.");

        $t2Candidate = $State['t2'];
        // 6 alfa.1. Проверка ЛЦ на пересечение ценой (не просто касание) при поиске альтернативных моделей
        $potentAL = (['bar' => $t2Candidate, 'level' => high($t2Candidate, $v), 'angle' => (high($State['t4'], $v) - high($t2Candidate, $v)) / ($State['t4'] - $t2Candidate)]);
        for ($iii = $t2Candidate + 1; $iii < $State['t4']; $iii++) { // перебор баров от проверяемой потенциальной т.2 (не вклюяая), до т.4 
            if (high($iii, $v) > lineLevel($potentAL, $iii)) { // 6 alfa.1.B. если пробивается ЛЦ 
                $State = myLog($State, " Найдено пересечение при кандидате в т.2 " . $iii . " т.4 = " . $State['t4'] . " t2Candidate = " . $t2Candidate);
                // $State['next_step'] = 'A2_step_12'; 
                $State['curBar'] = $State['t5'] + 2;
                $State['next_step'] = 'A2_step_2'; // 6 alfa.1.B. - alternative models searching continues with new p5
                $State2 = clearState($State, "t1p,t2p,t3p,t4p,t1,t2,t3,A2Prev");
                $State2 = myLog($State2, "Продолжение поиска альтернативной модели с бара (" . ($State['t5'] + 2));
                return ($State);
            }
        }
        // 6 alfa.1.A.- пересечения ЛЦ нет,переходим к 6.2.alfa
        // 6 alfa.2. Проверка ЛЦ и ЛТ пересекаются друг с другом справа (в будущем) при поиске альтернативных моделей
        $LT = A2_LT($State);
        $potentAL = (['bar' => $t2Candidate, 'level' => high($t2Candidate, $v), 'angle' => (high($State['t4'], $v) - high($t2Candidate, $v)) / ($State['t4'] - $t2Candidate)]);
        // РЕАЛИЗОВАТЬ ПРОВЕРКУ ДЛЯ т.5"
        $t3_ = (isset($State['t3\''])) ? $State['t3\''] : $State['t3']; // Е: ОШИБКА - было: $t3_ = (isset($State['t3\''])) ? 't3\'' : 't3'; - имя, а не номер бара
        $y_top = lineLevel($potentAL, $t3_); // цена на ЛЦ' на баре  т.3/т.3'
        $y_bottom = low($t3_, $v);
        $dy = $LT['angle'] - $potentAL['angle']; // на сколько сближаются ЛЦ' и ЛТ'вмп за 1 бар // Е: ОШИБКА - $potentAL - определеяется в предыдущем цикле - ее значение = последнему, определид заново
        if ($dy > 0) {  //  Расчётная т.6 найдена
            $t6 = $t3_ + ($y_top - $y_bottom) / $dy; // на каком баре находится пересечение (t6) - дробное значение
            $t6_level = lineLevel($potentAL, $t6);
            // Если ЛЦ и ЛТ отношение расстояний в барах т.2-т.4 к т.4-т.6 меньше значения по умолчанию параметра «Минимальное отношение т.2-т.4 к т.4-т.6 ВМП»,
            if (($State['t4'] - $t2Candidate) / ($t6 - $State['t4']) < B24to46) {
                $State = myLog($State, "ЛЦ и ЛТ ВМП сходятся слишком далеко, на расстоянии =" . ($State['t4'] - $t2Candidate) / ($t6 - $State['t4']) . " при B24to46 =" . B24to46 . " State['t4'] = " . $State['t4'] . " t2Candidate = " . $t2Candidate . " t6 = " . $t6 . " State['t4'] = " . $State['t4'] . " dy = " . $dy . " t3_ = " . $t3_);
                $State['next_step'] = 'stop'; // alternative models searching stops
                return ($State);
            }
        } else {
            $State = myLog($State, "Линии расходятся dy =" . $dy . "t2Candidate - " . $t2Candidate . " t4= " . $State['t4']);
            $State['next_step'] = 'stop'; // alternative models searching stops
            return ($State);
        }
        $State['next_step'] = 'A2_step_9';
        return ($State);
    }

    $State = myLog($State, "TMP - кол-во БО при старте п6 =" . count($State['p12candidates']));


    foreach ($State['p12candidates'] as $pk => $bo) { // перебираем все т.2 для этой модели в массиве $State['p2candidates'] //Е: $pk - индекс в массиве p12candidates
        // $t2 = $bo[0];
        $t2Candidate = $bo[0]; // где $i - это т.2 ВМП,
        // $P1candidate = $bo[1]; //$P1candidate - это т.1 ВМП
        // $confirmP2 = $bo[2];

        // 6.1. Проверка ЛЦ на пересечение ценой (не просто касание)
        //$potentAL = (['bar' => $t2Candidate, 'level' => low($t2Candidate, $v), 'angle' => (low($State['p4'], $v) - low($t2Candidate, $v)) / ($State['p4'] - $t2Candidate)]); // E: почему low? ОШИБКА?
        $potentAL = (['bar' => $t2Candidate, 'level' => high($t2Candidate, $v), 'angle' => (high($State['t4'], $v) - high($t2Candidate, $v)) / ($State['t4'] - $t2Candidate)]);
        for ($iii = $t2Candidate + 1; $iii < $State['t4']; $iii++) { // перебор баров от проверяемой потенциальной т.2 (не вклюяая), до т.4 // Е: ОЩИБКА было for ($iii = $t2Candidate + 1; $iii < high($State['t4'], $v); $iii++)
            if (high($iii, $v) > lineLevel($potentAL, $iii)) { // если пробивается ЛЦ // Е: стандартная ОШИБКА - было high($iii, $v) > $potentAL
                $State = myLog($State, " Найдено пересечение при кандидате в т.2 " . $iii . " т.4 = " . $State['t4'] . " t2Candidate = " . $t2Candidate);
                unset($State['p12candidates'][$pk]); //Е: ОШИБКА - было unset($State['p12candidates'][$bo]);  $bo - это не индекс, а массив
                break;
            }
        }
    }

    $State = myLog($State, "TMP - кол-во БО после 6.1. Проверка ЛЦ на пересечение ценой (не просто касание) =" . count($State['p12candidates']));

    if (count($State['p12candidates']) > 0) { // 6.1.А. Если найдены БО, дающие ЛЦ без пробоев, алгоритм переходит к пп.6.2.;
        foreach ($State['p12candidates'] as $pk => $bo) {
            $t2Candidate = $bo[0];
            $State = myLog($State, "Кандидат в т.2 = . $t2Candidate . ");
        }
        foreach ($State['p12candidates'] as $pk => $bo) { // 6.2. Проверка на пересечение ЛЦ и ЛТ друг с другом справа (в будущем) по оси времени. // Е: добавил индекс массива // Е: также добавил индекс
            $LT = A2_LT($State);
            $t2Candidate = $bo[0];
            $potentAL = (['bar' => $t2Candidate, 'level' => high($t2Candidate, $v), 'angle' => (high($State['t4'], $v) - high($t2Candidate, $v)) / ($State['t4'] - $t2Candidate)]);
            // РЕАЛИЗОВАТЬ ПРОВЕРКУ ДЛЯ т.5"
            $t3_ = (isset($State['t3\''])) ? $State['t3\''] : $State['t3']; // Е: ОШИБКА - было: $t3_ = (isset($State['t3\''])) ? 't3\'' : 't3'; - имя, а не номер бара
            $y_top = lineLevel($potentAL, $t3_); // цена на ЛЦ' на баре  т.3/т.3'
            $y_bottom = low($t3_, $v);
            $dy = $LT['angle'] - $potentAL['angle']; // на сколько сближаются ЛЦ' и ЛТ'вмп за 1 бар // Е: ОШИБКА - $potentAL - определеяется в предыдущем цикле - ее значение = последнему, определид заново
            if ($dy > 0) {  // Расчётная т.6 найдена
                $t6 = $t3_ + ($y_top - $y_bottom) / $dy; // на каком баре находится пересечение (t6) - дробное значение
                $t6_level = lineLevel($potentAL, $t6);
                // Если ЛЦ и ЛТ отношение расстояний в барах т.2-т.4 к т.4-т.6 меньше значения по умолчанию параметра «Минимальное отношение т.2-т.4 к т.4-т.6 ВМП»,
                if (($State['t4'] - $t2Candidate) / ($t6 - $State['t4']) < B24to46) {
                    unset($State['p12candidates'][$pk]); // то данные кандадиты в 1 и 2 отбрасываются // Е: ОШИБКА было unset($State['p12candidates'][$bo]) - $bo - это не индекс, а массив
                    $State = myLog($State, "ЛЦ и ЛТ ВМП сходятся слишком далеко, на расстоянии =" . ($State['t4'] - $t2Candidate) / ($t6 - $State['t4']) . " при B24to46 =" . B24to46 . " State['t4'] = " . $State['t4'] . " t2Candidate = " . $t2Candidate . " t6 = " . $t6 . " State['t4'] = " . $State['t4'] . " dy = " . $dy . " t3_ = " . $t3_);
                }
            } else {
                $State = myLog($State, "Линии расходятся dy =" . $dy . "unset t2Candidate - " . $t2Candidate);
                $State = myLog($State, "unset . $t2Candidate . ");
                unset($State['p12candidates'][$pk]);
            }
        }
        foreach ($State['p12candidates'] as $pk => $bo) {
            $t2Candidate = $bo[0];
            $State = myLog($State, "Кандидат в т.2 = . $t2Candidate . ");
        }


        $State = myLog($State, "TMP - кол-во БО после 6.2 Проверка на пересечение ЛЦ и ЛТ друг с другом справа (в будущем) =" . count($State['p12candidates']));

        if (count($State['p12candidates']) > 0) { // 6.2.А. Осталось 1 или несоклько потенциальных БО
            $State['next_step'] = 'A2_step_7'; // программа переходит к п.7
            return [$State];
        } else { // 6.2.Б Если подходящиш БО нет, алгоритм ищет новую т.5 по п.2 либо выходит при draw_flag=true
            $State['curBar'] = $State['t5'] + 2;
            if (isset($State['draw_flag'])) {
                $State['next_step'] = 'stop';
                $State = myLog($State, "6.2.Б.(draw_flag) Временную модель отрисовать не удалось!");
                return [$State];
            } else {
                $State = clearState($State, "t3,A2Prev"); // Е: добавил очистку от лишних параметров
                $State['next_step'] = 'A2_step_2';
                $State = myLog($State, "6.2.Б.Потенциальных БО не осталось – в этом случае программа ищет новую потенциальную т.5, начиная с п.2 и далее. ");
                return [$State];
            }
        }
    } else { // 6.1.Б Если подходящиш БО нет, алгоритм ищет новую т.5 по п.2
        if (isset($State['draw_flag'])) {
            $State['next_step'] = 'stop';
        } else {
            $State['curBar'] = $State['t5'] + 1;
            $State = clearState($State, "t3,A2Prev"); // Е: добавил очистку от лишних параметров
            $State['next_step'] = 'A2_step_2';
        }
        return [$State];
    }
}

function A2_step_7($State)
{ // 7. Определение БО с 2x5 и без

    $State = A2_myLog_start($State, "7");
    $State = myLog($State, "TMP - кол-во БО при старте п7 =" . count($State['p12candidates']));
    $v = $State['v'];
    $State['next_step'] = 'A2_step_8';
    if (count($State['p12candidates']) < 2) {
        $State = myLog($State, "количество p12candidates = " . count($State['p12candidates']) . " идем сразу на step_8");
        // unset($State['p12candidates2x5']);
        return [$State];
    }
    $cnt_2x5 = 0; // сколько БО с пересечением 2x5
    $bestBO_pk = -1; // наиболее подходящий БО (его индекс) с 2x5
    $lvl23 = false;
    foreach ($State['p12candidates'] as $pk => $bo) {
        $t2Candidate = $bo[0]; // $t2Candidate - это т.2 ВМП,
        if (max(open($t2Candidate, $v), close($t2Candidate, $v)) >= min(open($State['t5'], $v), close($State['t5'], $v))) { //"пересечениz тел есть  - т.е. тело свечи т2 не целиком ниже т5
            //  $State=myLog($State," pk=$pk 2x5 найдена");
            $dist23 = abs(high($t2Candidate, $v) - low($State['t3'], $v));
            $cnt_2x5++; // считаем, сколько БО с 2х5
            if (!$lvl23 || $dist23 < $lvl23) { // считаем расстояние от т.2 до т.3, если меньше ранее зафиксированного, то данный БО более приоритетный
                $bestBO_pk = $pk; // устанавливаем номер наилучшего БО с 2х5 в массиве
                $lvl23 = $dist23;
            }
        }
    } // прошли все БО, определили сколько с 2х5, номер наилучшего БО с 2х5 - далее убираем из массива все лишние БО
    $isWithout2x5Exists = (count($State['p12candidates']) > $cnt_2x5) ? true : false; // есть ли БО без 2х5
    //    $State=myLog($State,"TMP isWithout2x5Exists=$isWithout2x5Exists cnt_2x5=$cnt_2x5 best_pk=$bestBO_pk count(BO)=".count($State['p12candidates']));
    foreach ($State['p12candidates'] as $pk => $bo) {
        $t2Candidate = $bo[0]; // $t2Candidate - это т.2 ВМП,
        //        $State=myLog($State,"TMP смотрим БО с pk=$pk");
        if ((max(open($t2Candidate, $v), close($t2Candidate, $v)) >= min(open($State['t5'], $v), close($State['t5'], $v))) && ($isWithout2x5Exists || $pk !== $bestBO_pk)) { // есть 2х5 и либо 1) есть БО без 2х5 либо 2) эта не самая близкая по  2_3
            //            $State=myLog($State,"TMP стираем БО с pk=$pk bestBO_pk=$bestBO_pk условие=".(max(open($t2Candidate, $v), close($t2Candidate, $v)) >= min(open($State['t5'], $v), close($State['t5'], $v))));
            unset($State['p12candidates'][$pk]);
        }
    }
    $State = myLog($State, "В массиве осталось " . count($State['p12candidates']) . " БО (isWithout2x5Exists=$isWithout2x5Exists)");
    return ($State);
}
function A2_step_8($State)
{ // 8. ФИЛЬТР ПО ПРЕСУППОЗИЦИИ.
    $State = A2_myLog_start($State, "8");
    $State = myLog($State, "TMP - кол-во БО при старте п8 =" . count($State['p12candidates']));

    if (
        !isset($State['Presupp'])
        || count($State['Presupp']) == 0
    ) { // 8.0. Если Пресуппозиции не найдены, программа переходит к п.9.
        $State = myLog($State, "8.0. Пресуппозиции не найдены, переходим к п.9.");
        $State['next_step'] = 'A2_step_9';
        return [$State];
    }
    $bestPresupp = false; // сюда в следующем цикле сохраним индекс ($pk) пресуппозиции, у которой t1p правее всех по оси времени, это нужно в п.8.2.А
    foreach ($State['Presupp'] as $pk => $Presupp) {
        // Осуществляется проверка на принадлежность имеющихся кандидатов в т.2 к участку между последним пересечением ценой уровня т.1п и самой т.1п. (т.1п. тоже может быть использована в качестве т.2 ВМП).
        $confirmedPressup = false; // это переменная, с помощью которой мы проверяем валидность пресуппозий (должна быть хотя бы одна пресуппозиция, содержащая БО)
        foreach ($State['p12candidates'] as $bo) {
            $t2Candidate = $bo[0]; // где $i - это т.2 ВМП,
            if ( // 8.1.1. Есть кандидат(ы) в т.2, которые находятся на участке между последним пересечением ценой уровня т.1п и самой т.1п. Такая Пресуппозиция сохраняется.
                $t2Candidate <= $Presupp['t1p'] //  находится перед или совпадает с т.1п
                && $t2Candidate > $Presupp['confirmT1p'] // на участке после подтверждения т.1п
            ) {
                $confirmedPressup = true; // добавляем пресуппозиции признак подтвержденной
                break; // один БО нашли и хватит
            }
        } // проверили наличие БО в рамках одной пресуппозиции
        if ($confirmedPressup) { // 8.1.1. Есть кандидат(ы) в т.2, которые находятся на участке между последним пересечением ценой уровня т.1п и самой т.1п. Такая Пресуппозиция сохраняется.
            // Е: сразу добавил проверку - t1p должна быть правее по оси  времени, чем ранее найденная
            if ($bestPresupp === false) $bestPresupp = $pk; // это первая подтвержленная пресуппозиция
            else {
                if ($Presupp['t1p'] > $State['Presupp'][$bestPresupp]['t1p']) { // t1p у новой правее чем у ранее найденной - убираем старую (п.8.2.А)
                    $State = myLog($State, "8.1.1. Исключена Пресуппозиция № " . (count($State['Presupp']) . "от т.1п= " . $Presupp['t1p']));
                    unset($State['Presupp'][$bestPresupp]);
                    $bestPresupp = $pk; // обновили значение фаворита
                } else { // t1p у новой ЛЕВЕЕ чем у ранее найденной - убираем ТЕКУЩУЮ (п.8.2.А)
                    $State = myLog($State, "8.2.А. Исключена Пресуппозиция № " . (count($State['Presupp']) . "от т.1п= " . $Presupp['t1p']));
                    unset($State['Presupp'][$pk]);
                }
            }
        } else { // 8.1.2. Нет кандидатов в т.2, которые находятся на участке между последним пересечением ценой уровня т.1п и самой т.1п. В данном случае такая Пресуппозиция отбрасывается и  больше не рассматривается
            $State = myLog($State, "8.1.2. Исключена Пресуппозиция № " . (count($State['Presupp']) . "от т.1п= " . $Presupp['t1p']));
            unset($State['Presupp'][$pk]);
        }
    } // проверили все пресуппозиции на наличие БО и оставили только одну прессуппозицию (либо отвергли все)
    // Б.В качестве т.2 оставляются только те кандидаты, которые принадлежат участку между последним пересечением ценой уровня т.1п и самой т.1п оставшейся Пресуппозиции.
    if (count($State['Presupp']) > 0) {
        foreach ($State['Presupp'] as $pkp => $Presupp) { // она всего одна, но цикл, что-бы определить индекс (мы там постирали много и он может быть не 0 (вероятно)
            $State = myLog($State, " Отбираем БО для оставшейся пресуппозиции pk = $pkp");
            foreach ($State['p12candidates'] as $pk => $bo) {
                $t2Candidate = $bo[0]; // где $i - это т.2 ВМП,
                //unset($confirmedBO);
                if (!( // ... принадлежат участку между последним пересечением ценой уровня т.1п и самой т.1п оставшейся Пресуппозиции.
                    $t2Candidate <= $Presupp['t1p'] //  находится перед или совпадает с т.1п
                    && $t2Candidate > $Presupp['confirmT1p'] // на участке после подтверждения т.1п
                )) {
                    unset($State['p12candidates'][$pk]); // удаляем данный БО
                }
            } // проверили все БО по оставшейся пресуппозиции, убрали лишние
            $State = myLog($State, " Заменяем индекс пресуппозиции pk = $pkp на 0");
            $State['Presupp'][0] = $State['Presupp'][$pkp];
            unset($State['Presupp'][$pkp]);
        }
        if (count($State['p12candidates']) == 1) { // 8.2.1. Если остается только 1 потенциальный БО, модель фиксируется  // Е: должно быть обращение по индеесу
            $State = myLog($State, " 8.2.1 Остался только один 1 потенциальный БО - фиксируем модель");
            $State = myLog($State, "8.2.1 Определили t2 как единственный БО[0]");
            $State['t2'] = $t2Candidate;
            //$State = A2_fix_model($State, "Найдена т.2 ВМП в п.8"); // фиксируем модель
            $State['next_step'] = 'A2_step_9';
        } else { // 8.2.2. Если остается более 1 потенциального БО, программа переходит к п.9.
            $State = myLog($State, " 8.2.2 Осталоcь потенциальных БО :" . count($State['p12candidates']) . " идем на step_9");
            $State['next_step'] = 'A2_step_9';
        }
        return [$State];
    } else { // не осталось пресуппозиций - переходим к step 9
        $State = myLog($State, " Не осталось пресуппозиций - идем на step 9");
        unset($State['Presupp']); // Е: не уверен, что это нужно, но на всякий случай
        $State['next_step'] = 'A2_step_9';
        return [$State];
    }
}
function compare_IDinners($model1, $model2)
{
    if (($model1['t4'] - $model1['t1']) > ($model2['t4'] - $model2['t1'])) return (-1);
    if (($model1['t4'] - $model1['t1']) < ($model2['t4'] - $model2['t1'])) return (1);
    if ($model1['t1'] < $model2['t1']) return (-1);
    if ($model1['t1'] > $model2['t1']) return (1);
    return (0);
}
function A2_step_9($State)
{ // 9. ПОИСК ВПИСАННОЙ В ВМП МОДЕЛИ.
    // Выбор из ранее найденных в Алгоритме_1 и переданных сюда
    global $Models_Alg1;
    $State = A2_myLog_start($State, "9");
    // $State = myLog($State, "TMP - кол-во БО при старте п9 =" . count($State['p12candidates']));
    if (!isset($State['t2'])) $State = myLog($State, "TMP - кол-во БО при старте п9 =" . count($State['p12candidates'])); // 
    $v = $State['v'];
    if (!isset($State['t3\''])) {
        $State = myLog($State, "Модель построена не через t3' - сразу переходим к step_10");
        $State['next_step'] = 'A2_step_10';
        return ($State);
    }
    // 9.1. Если ВМП строится через т.3', то на участке от т.3 ВМП происходит поиск моделей по Алгоритму I, для которых соблюдаются одновременно 2 условия:
    //-т.4 которых лежит не далее т.4 рассматриваемой ВМП; (т.4(1) не может совпадать с т.3(2), но может совпадать с т.4(2);
    //-т.1 лежит перед т.3' анализируемой модели (если совпадает с т.3', то уже не подходит)  (т.1(1) может совпадать с т.3(2), но не может совпадать с т.3'(2)
    $cnt = 0;
    $npp = 0; // просто для лога - счетчик - сколько нашли IDinners для State
    foreach ($Models_Alg1 as $pkm => $Models_1) {
        foreach ($Models_1 as $pk => $Model_1) { //перебираем все модели из массива моделей первого алгоритма
            $cnt++;
            if (
                $Model_1['t4'] <= $State['t4'] && $Model_1['t4'] > $State['t3'] // -т.4 которых лежит не далее т.4 рассматриваемой ВМП; (т.4(I)  не может совпадать с т.3(II), но может совпадать с т.4(II); 
                && $Model_1['t1'] < $State['t3\''] && $Model_1['t1'] >= $State['t3'] // -т.1 лежит перед т.3' анализируемой модели (если совпадает с т.3', то уже не подходит)  (т.1(I) может совпадать с т.3(II), но не может совпадать с т.3'(II)
                && ( // если модель по алгоритму 1 содержит т.5, то её т.5 должна лежать перед т.5 рассматриваемой ВМП
                    (isset($Model_1['t5']) && $Model_1['t5'] <= $State['t5'])
                    || (!isset($Model_1['t5']) && $Model_1['t4'] <= $State['t4']))
            ) {
                $State = myLog($State, (++$npp) . ") добавляем еще один IDinner (t4_t1_dist=" . ($Model_1['t4'] - $Model_1['t1']) . ") _points=" . $Model_1['param']['_points']);
                //  $Model_1['TMP_4x1_dist'] = $Model_1['t4'] - $Model_1['t1'];
                $Model_1['key'] = 'm1-' . $pkm . '-' . $pk;
                $State['IDinners'][] = $Model_1;
                //$State['IDinners'][] = $Model_1['key'];
            }
        }
    }
    $modelsFound = isset($State['IDinners']) ? count($State['IDinners']) : 0;

    $State['status']["TMP Найдено IDinners: " . $modelsFound] = 0; // временный статус - для отладки и подсчета количества
    $State = myLog($State, "Найдено IDinners: " . $modelsFound . " перебрали моделей: " . $cnt);
    if (!isset($State['IDinners'])) {
        $State = myLog($State, " IDinners не найдены - идем на step_10");
        $State['param']['E1'] = 'EAMsimple';
        $State['next_step'] = 'A2_step_10';
        return ($State);
    }
    //$res['TMP_IDinners_cnt']++;
    $State['param']['E1'] = 'EAMplusEM';
    if (count($State['IDinners']) > 5) { // найдено более 5 IDinners моделей - сортируем и оставляем те, у которых расстояние от т.1 до т.4 больше остальных.
        usort($State['IDinners'], "compare_IDinners");
        $State = myLog($State, "Удаляем " . ($npp - 5) . " \"худших\" IDinners");
        $State['IDinners'] = array_slice($State['IDinners'], 0, 5); // оставляем первые 5 после сортировки
    }
    // 9.1.3. Если ВМП имеет одну или несколько вписанных моделей, то среди них ищутся модели, построенные от т.3 ВМП и при этом отвечающие одному из следующих признаков:
    //    А. у которой трендовая пробита на участке до т.3' анализируемой модели;
    //    Б. имеющая пересечение тел свечей точек 2 и 5 (далее 2x5).
    //    В. если вписанная модель имеет ранг 45 больше рангов 12 и 25 этой же модели.

    $State['param']['E3'] = "Regular 1st check"; // ставим по умолчанию
    foreach ($State['IDinners'] as $pk => $Model_1)
        if ($Model_1['t1'] == $State['t3']) { // модель построена от т.3 ВМП
            $State = myLog($State, " 9.1.3 Нашли модель(1) построенную от Т3_ВМП - проверяем ее на условия А,Б,В");
            //А. у которой трендовая пробита на участке до т.3' анализируемой модели;  // ПРОВЕРИТЬ - мутная тема
            $LT1 = LT($Model_1);
            $isLT1_broken = false;
            for ($i = $State['t3']; $i <= $State['t3\'']; $i++) {
                if (low($i, $v) < lineLevel($LT1, $i)) {
                    $isLT1_broken = $i;
                    break;
                }
            }
            if ($isLT1_broken) {
                $State = myLog($State, " 9.1.3.А Найдена модель(1) id=" . $Model_1['id'] . " у которой трендовая пробита на участке до т.3' анализируемой модели -> E3=Specific 1st check");
                $State['param']['E3'] = 'Specific 1st check';

                $State['IDinners'][$pk]['key'] = $Model_1['key'] . "-" . 'IDinner_1';
                break; // дальше ничего не анализируем // ?????
            }
            //Б. имеющая пересечение тел свечей точек 2 и 5 (далее 2x5).
            if ( //BarsIntersection($Model_1['t2'],$Model_1['t2'])
                isset($Model_1['t5']) &&
                (max(open($Model_1['t2'], $v), close($Model_1['t2'], $v)) > min(open($Model_1['t5'], $v), close($Model_1['t5'], $v)))
            ) { // есть пересечение тел свечей 2 и 5
                $State = myLog($State, " 9.1.3.Б Найдена модель(1) id=" . $Model_1['id'] . " с пересечением тел свечей t2 и t5 -> E3=Specific 1st check");
                $State['param']['E3'] = 'Specific 1st check';

                $State['IDinners'][$pk]['key'] = $Model_1['key'] . "-" . 'IDinner_1';
                break; // дальше ничего не анализируем // ?????
            }
            // В. если вписанная модель имеет ранг 45 больше рангов 12 и 25 этой же модели.
            if (isset($Model_1['t5'])) {
                $rank45 = abs(high($Model_1['t4'], $v) - low($Model_1['t5'], $v)); // вроде как abs не нужен
                $rank12 = abs(high($Model_1['t2'], $v) - low($Model_1['t1'], $v));
                $rank25 = abs(high($Model_1['t2'], $v) - low($Model_1['t5'], $v));
                if ($rank45 > $rank12 && $rank45 > $rank25) {
                    $State = myLog($State, " 9.1.3.В вписанная модель  id=" . $Model_1['id'] . " имеет ранг 45 больше рангов 12 и 25 этой же модели. -> E3=Specific 1st check");
                    $State['param']['E3'] = 'Specific 1st check';

                    $State['IDinners'][$pk]['key'] = $Model_1['key'] . "-" . 'IDinner_1';
                    break; // дальше ничего не анализируем // ?????
                }
            }
        } // Закончили первый перебор Моделей(1) по п. 9.1.3
    //9.1.4. Если на участке от т.3 до т.3' ВМП есть модель по Алгоритму I сонаправленная с трендом, предшествующим ВМП, и у которой точки т.1-т.4 лежат на участке 3-3' ВМП(включительно), то данная ВМП является Специфической по 2-му признаку
    // новый аналогичный цикл - перебор Моделей(1) по п. 9.1.4
    $State['param']['E4'] = 'Regular 2nd check'; // по умолчанию, если ничего не найдем
    foreach ($State['IDinners'] as $pk => $Model_1) {
        $v1 = $Model_1['v'];
        if ($v1 == not_v($v)) { // на участке от т.3 до т.3' ВМП есть модель по Алгоритму I сонаправленная с трендом, предшествующим ВМП
            if ($Model_1['t1'] >= $State['t3'] && $Model_1['t4'] <= $State['t3\'']) { //и у которой точки т.1-т.4 лежат на участке 3-3' ВМП(включительно), то данная ВМП является Специфической по 2-му признаку.
                $State = myLog($State, " 9.1.4 Найдена модель у которой у которой точки т.1-т.4 лежат на участке 3-3' ВМП(включительно) id=" . $Model_1['id'] . "  -> E4=Specific 2nd check");
                $State['param']['E4'] = 'Specific 2nd check';

                $State['IDinners'][$pk]['key'] = $Model_1['key'] . "-" . 'IDinner_1';
                break; // дальше ничего не анализируем // ?????
            }
        }
    }
    // новый блок - убираем сами модели, сохраняем тольк keys
    $IDinners = [];
    foreach (($State['IDinners']) as $pk => $pv) {
        $IDinners[] = $pv['key'];
    }
    $State['IDinners'] = $IDinners;

    $State['next_step'] = 'A2_step_10';
    // стираем сами модели, передаем только key (номер бара : номер модели на данном баре)
    //    $arKeys=[];
    //    foreach($State['IDinners'] as $IDinner){
    //        $arKeys[]=$IDinner['key'];
    //    }
    //    $State['IDinners']=$arKeys;
    return ($State);
}
//function BarsIntersection($bar1,$bar2){ // служебная функция - возврящает true, если тела баров пересекаются и false в противном случае
//    $min1=min(open($bar1,"low"),close($bar1,"low")); // для определения пересечения - low или high не важно, указываем low
//    $max1=max(open($bar1,"low"),close($bar1,"low"));
//    $min2=min(open($bar2,"low"),close($bar2,"low"));
//    $max2=max(open($bar2,"low"),close($bar2,"low"));
//    if($min1>$max2||$max1<$min2)return(false); // пересечений нет
//    return(true);
//}
// function compare_IDprevs_P1($model1, $model2)
// {
//     if ($model1['t1'] < $model2['t1']) return (-1);
//     if ($model1['t1'] > $model2['t1']) return (1);
//     return (0);
// }
function compare_IDprevs($model1, $model2)
{
    if ($model1['t4'] > $model2['t4']) return (-1);
    if ($model1['t4'] < $model2['t4']) return (1);
    // if ($model1['t4'] == $model2['t4']) 
    // {
    if ($model1['t1'] < $model2['t1']) return (-1);
    if ($model1['t1'] > $model2['t1']) return (1);
    if ($model1['param']['_points'] < $model2['param']['_points']) return (-1);
    // }
    return (1);
}

function compare_IDprevs_AII($model1, $model2) // вызов Compare_IDprevs_AII также содержится в build_models_common
{
    if ($model1['t4'] > $model2['t4']) return (-1);
    if ($model1['t4'] < $model2['t4']) return (1);
    // if ($model1['t4'] == $model2['t4']) 
    // {
    // ! fix 22/04/22
    // if ($model1['t1'] < $model2['t1']) return (-1);
    // if ($model1['t1'] > $model2['t1']) return (1);
    if ($model1['t1'] < $model2['t1']) return (1);
    if ($model1['t1'] > $model2['t1']) return (-1);
    // }
    if ($model1['type'] == "непосредственно предшествующая" && $model2['type'] != "непосредственно предшествующая") return (-1);
    if ($model1['type'] == "предшествующая коррекционная" && $model2['type'] != "предшествующая коррекционная") return (1);
    //file_put_contents("____tmp___model1.json",json_encode($model1));
    //file_put_contents("____tmp___model2.json",json_encode($model2));
    if ($model1['param']['_points'] < $model2['param']['_points']) return (-1);
    return (1);
}

function A2_step_10($State)
{ // 10. ПОИСК ПРЕДШЕСТВУЮЩИХ МОДЕЛЕЙ.
    global $Models_Alg1, $Chart;
    $v = $State['v'];
    $State = A2_myLog_start($State, "10");
    // $State = myLog($State, "TMP - кол-во БО при старте п10 =" . count($State['p12candidates']));
    if (!isset($State['t2'])) $State = myLog($State, "TMP - кол-во БО при старте п10 =" . count($State['p12candidates'])); // Выводим в лог кроме случая,когда есть заранее опредлеенная т.2 (например случай, когда идёт поиск альтернативной модели
    if (!isset($State['t2']))
        if (isset($State['p12candidates']) && count($State['p12candidates']) > 0) foreach ($State['p12candidates'] as $pk => $bo) {
            $State['t2'] = $bo[0];
            $State = myLog($State, "Поставили временную заглушку - т2 = BO[$pk][0]=" . $bo[0]);
        }
        else {
            $State['t2'] = $State['A2Prev'];
            $State = myLog($State, "ERROR Как мы сюда попали - Поставили временную заглушку - т2 = A2Prev" . $State['A2Prev']);
        }

    //$cnt=0;
    $npp = 0; // просто для лога - счетчик - сколько нашли IDprev для State
    $Models_1 = [];
    // foreach ($Models_Alg1 as $pkm => $Model_Alg1)
    foreach ($Models_Alg1 as $pkm => $Model_Alg1) if ($pkm < $State['t3'])
        foreach ($Model_Alg1 as $pk => $Model_1) { //перебираем все модели из массива моделей первого алгоритма

            $npp++;
            $v1 = $Model_1['v'];
            // $State = myLog($State, "Проверяем модель m1-$pkm-$pk" );
            //$cnt++;
            if (
                $Model_1['t1'] >= $State['A2Prev']
                // && $Model_1['t1'] < $State['t3'] // перенесено в цикл моделей 1-го алгоритма
                && $Model_1['t4'] <= $State['t3']
            ) { // т.1 модели лежит перед т.3 рассматриваемой ВМП и т.4 лежит перед или совпадает с т.3 рассматриваемой ВМП
                $State = myLog($State, "начальное условие для пердшествующей модели модели m1-$pkm-$pk пройдено"); // $pkm - номер бара т.1,$pk - порядковый номер моделей на этой 1-ой точке
                // ищем правую границу поиска t6/t6Supp
                $LT = LT($Model_1); // обращаемся с Model а не State - там тоже есть нужные параметры (t1,t3,t3') // линия тренда прешествующей модели
                $isLTbreakFound = false; // нашли ли пересечение/касание LT(1) или просто дошли до  STEP10LIMIT? т.е. ищем реальную Т6 или P6supp

                $searchborder = $State['t4'];
                if (isset($State['conf_t4'])) $searchborder = $State['conf_t4'];
                // for ($i = $Model_1['t4'] + 1; $i < $Model_1['t1'] + STEP10LIMIT && $i < nBars; $i++) { //ищем пересечение ЛТ(I) но не далее глубины поиска для step_10 или конца графика
                // for ($i = $Model_1['t4'] + 1; $i < $searchborder && $i < nBars; $i++) { //ищем пересечение ЛТ(1) но не далее точки подтверждения т.4 рассматриваемой модели или конца графика
                for ($i = $Model_1['t4']; $i < $searchborder && $i < nBars; $i++) { //ищем пересечение ЛТ(I) но не далее точки подтверждения т.4 рассматриваемой модели/бара подтверждения т.4 или конца графика
                    if (low($i, $v1) <= lineLevel($LT, $i)) { // есть пробой/касание ЛТ(I)?
                        $isLTbreakFound = true;
                        // $LT_broken = $i;
                        $LT_broken_searchborder = $i;
                        break;
                    }
                }

                // if (!isset($LT_broken)) {
                // $LT_broken = $i - 1; // если дошли до глубины поиска и не нашли касания LT, то просто устанавливаем правую границу на глубину поиска
                // if (!isset($LT_broken_searchborder)) {
                if ($isLTbreakFound == false) {
                    $LT_broken_searchborder = $searchborder; // если дошли до т.4/т.4 подтверждения т.4 рассматриваемой модели и не нашли касания LT, то просто устанавливаем правую границу на т.4/т.4 подтверждения рассматриваемой модели
                    // $State = myLog($State, " дошли до глубины поиска пробоя ЛТ $LT_broken");
                    // $State = myLog($State, " дошли до глубины поиска пробоя ЛТ $LT_broken_searchborder");
                    $State = myLog($State, " дошли до пробоя ЛТ/т.4 или подтверждения т.4 рассматриваемой модели $LT_broken_searchborder");
                }
                // $State = myLog($State, " прошли цикл поиска пробоя ЛТ с " . ($Model_1['t1'] + 1) . " по " . ($i - 1) . " isLTbreakFound=$LT_broken");
                // $State = myLog($State, " прошли цикл поиска пробоя ЛТ с " . ($Model_1['t1'] + 1) . " по " . ($i - 1) . " isLTbreakFound=$LT_broken_searchborder");
                $State = myLog($State, " прошли цикл поиска пробоя ЛТ с " . $Model_1['t4'] . " по " . ($i - 1) . " isLTbreakFound=$LT_broken_searchborder");
                // далее мщем абсолютный экстремум (t6/t6Supp)
                $t6_level = low($Model_1['t1'], $v1); // начальный - мин.уровень, он точно должен быть превышен
                // $State = myLog($State, " ищем реальную t6 с " . $Model_1['t1'] . " до $LT_broken");
                $State = myLog($State, " ищем реальную t6 с " . $Model_1['t1'] . " до $LT_broken_searchborder");
                // for ($i = $Model_1['t1']; $i < $LT_broken; $i++) {
                unset($t6);
                for ($i = $Model_1['t1']; $i < $LT_broken_searchborder; $i++) {
                    if (is_extremum($i, not_v($v1)) && high($i, $v1) > $t6_level) {
                        $t6_level = high($i, $v1);
                        $t6 = $i; // новый кандидат в абс. экстремум (t6)
                        // $State = myLog($State, " нашли кандидат в t6 $t6");
                    }
                }

                if (isset($t6)) {
                    if ($isLTbreakFound) $Model_1['t6'] = $t6; // если был пробой, значит найдена реальная t6 предшествующей модели
                    else  $Model_1['t6Supp'] = $t6; // иначе - предполагаемая t6
                    // определяемм "тип" модели - "непосредственно предшествующая" или "предшествующая коррекционная" или "none" - если нам не подходит
                    $Model_1['type'] = "none"; // первоначально присваиваемое значение
                    $Model_1['key'] = 'm1-' . $pkm . '-' . $pk; // $pkm - номер бара т.1,$pk - порядковый номер моделей на этой 1-ой точке
                }
                $t6_ind = isset($Model_1['t6']) ? 't6' : 't6Supp';
                if (!isset($Model_1[$t6_ind])) {
                    $State = myLog($State, "TMP ERROR - не определена t6_ind");
                    $State['status']['ЗАГАДОЧНАЯ ОШИБКА не определена t6_ind max_bar=' . date("Y-m-d H:i:s", $Chart[nBars - 1]['close_time'])] = 0;
                }

                // if($Model_1[$t6_ind]==$State['t3']){ // t6(1) совпал с t3 ВМР
                //     $Model_1['type']="непосредственно предшествующая";
                //     $Model_1['key'].="-".$Model_1[$t6_ind]."-1"; // добавляем информацию к ключу (t6+ тип модели) (на случай, если потом не будем копировать сами модеди а только ключи)
                // }
                // else{
                //     $Model_1['type']="предшествующая коррекционная";
                //     $Model_1['key'].="-".$Model_1[$t6_ind]."-2"; // добавляем информацию к ключу  (тип=2 = предшествующая коррекционная)
                // }
                // $State=myLog($State,"Добавили модель ".$Model_1['key']);
                // if(isset($Model_1[$t6_ind]))$Models_1[]=$Model_1; // добавляем в массив найденных моделей

                if (isset($Model_1[$t6_ind])) {
                    if ($Model_1[$t6_ind] == $State['t3']) { // Реальная/предполагаемая т.6 равна т.3 ВМП;
                        if (
                            // $Model_1[$t6_ind] == $State['t3'] && 
                            $v1 != $State['v'] // при этом модель противонаправленна рассматриваемой
                        ) { // t6(I) совпал с t3 ВМП
                            $Model_1['type'] = "непосредственно предшествующая";
                            $Model_1['key'] .= "-" . $Model_1[$t6_ind] . "-1"; // добавляем информацию к ключу (t6+ тип модели) (на случай, если потом не будем копировать сами модели а только ключи)
                            $State = myLog($State, "Добавили модель " . $Model_1['key']);
                            $Models_1[] = $Model_1; // добавляем в массив найденных моделей
                        }
                        // else
                        if (
                            $Model_1[$t6_ind] <= $State['t3']
                            && $v1 == $State['v']
                            // ВНЕСЕНО 30.06.2021 (РАНЕЕ НЕ БЫЛО УЧТЕНО)
                            && high($Model_1[$t6_ind], $v1) < high($State['t4'], $v)
                        ) {
                            $Model_1['type'] = "предшествующая коррекционная"; // J определяем t4-тип
                            $Model_1['key'] .= "-" . $Model_1[$t6_ind] . "-2"; // добавляем информацию к ключу  (тип=2 = предшествующая коррекционная)
                            $State = myLog($State, "Добавили модель " . $Model_1['key']);
                            $Models_1[] = $Model_1; // добавляем в массив найденных моделей
                        }
                        // $State = myLog($State, "Добавили модель " . $Model_1['key']);
                        // $Models_1[] = $Model_1; // добавляем в массив найденных моделей
                    }
                }
            }
        } //перебрали все модели (I) по каждой т1

    // Из моделей с одинаковой t4(I) оставляем по одной модели каждого типа "непосредственно предшествующая" и "предшествующая коррекционная"
    // оставляем по одной модели каждого типа (см.выше) - для каждой t4(I) - для этого сперва определяем массив t4(1)-тип
    $t4_1_keys = [];
    foreach ($Models_1 as $m) if (!in_array(($m['t4'] . '-' . $m['type']), $t4_1_keys)) $t4_1_keys[] = $m['t4'] . '-' . $m['type']; // добавляем новую t4-тип из массива отобранных моделей(1)
    foreach ($t4_1_keys as $t4_key) { // для каждого т4(1) выбираем по одной модели каждого типа
        $arTmp = explode('-', $t4_key);
        $t4_ = $arTmp[0]; // номер бара t4
        $type_ = $arTmp[1]; // тип
        $lastT5 = -1; // последняя найденная t5
        $lastPk = -1; // индекс модели  с последней найденной t5
        foreach ($Models_1 as $pk => $m) { // перебор всех найденных моделей
            if ($m['t4'] == $t4_ && $m['type'] == $type_) { // берем только нужные t4 и тип (из внешнего цикла
                $t5_ = (isset($m['t5'])) ? $m['t5'] : (nBars + 1); // t5 либо 0, если t5 не определена
                if ($lastT5 < $t5_) { // эта модель "лучше"?
                    if ($lastPk >= 0) unset($Models_1[$lastPk]); // стираем ранее найденную, если такая есть
                    $lastPk = $pk;
                    $lastT5 = $t5_;
                }
            }
        }
    }
    $State = myLog($State, "найдено IDprevs: " . count($Models_1));
    $State['status']['TMP найдено IDprevs: ' . count($Models_1)] = 0;
    // usort($Models_1, "compare_IDprevs");
    usort($Models_1, "compare_IDprevs_AII"); // Compare_IDprevs_AII содержится в build_models_common 
    if (count($Models_1) > 10) { // редкий случай - осталось более 10 моделей
        $State = myLog($State, "Осталось >10 моделей - оставляем 10 последних - у которых t4 позднее других");
        // usort($Models_1, "compare_IDprevs");
        $Models_1 = array_slice($Models_1, 0, 10); // оставляем первые 10 после сортировки
    }
    // Перенесено в build_models_common
    // added 13/01/22 Вносим в рассматриваемую модель параметр,отражающий тип значимой предшествующей модели
    if (isset($Models_1[0])) {
        $State['param']['PrevType'] = $Models_1[0]['param']['G1'];
        // $State['param']['PrevT1'] = $Models_1[0]['t1']; //  Временный параметр для тестирования,убрать
        // $State['param']['PrevT4'] = $Models_1[0]['t4']; //  Временный параметр для тестирования,убрать
    }

    $IDprevs = [];
    foreach ($Models_1 as $pk => $pv) {
        $IDprevs[] = $pv['key'];
    }
    //$State['IDprevs']=$Models_1;
    $State['IDprevs'] = $IDprevs;
    if (isset($State['IDprevs'][0]))
        $State['IDprevs'][0] = $State['IDprevs'][0] . "-" . "IDprev_0"; // - IDprev_0 - последняя по времени непосредственно предшествующая модель
    $State['next_step'] = 'A2_step_11';
    return ([$State]);
}

function compare_IDprevs_step11($key1, $key2)
{ // ищем по ключу модели первого алгоритма и возвращаем (-1), если у первой модели т1 правее
    global $Models_Alg1;
    $arr1 = explode("-", $key1);
    $arr2 = explode("-", $key2);
    $model1 = $Models_Alg1[$arr1[1]][$arr1[2]]; // например если "m1-p891-1-894-2" (первый алш-номер точки на чарте- номер модели в массиве моделей данной точки (t1) - t6 - тип (1или2 непосредственная или коррекционная)- берем "p891" и "1"
    $model2 = $Models_Alg1[$arr2[1]][$arr2[2]];
    // // ! fix 22/04/22
    // if ($model1['t1'] > $model2['t1']) return (-1);
    // if ($model2['t1'] > $model1['t1']) return (1);
    // Вариант сортировки - модель с более ранней т.1 перемещается в начало массива
    if ($model1['t1'] < $model2['t1']) return (1);
    if ($model1['t1'] > $model2['t1']) return (-1);
    return (0);
}
function A2_step_11($State)
{ // 11. ОКОНЧАТЕЛЬНЫЙ ВЫБОР Т.2 
    global $res, $Models_Alg1;
    $State = A2_myLog_start($State, "11");
    $v = $State['v'];

    // ! Next line added  recently ~ 04/22 
    if (!isset($State['t2'])) {  // * Incase we got point 2 already set by this moment we are in the alternative  model searching branch, we go to 11 alfa

        //$State = myLog($State, " ЗАГЛУШКА - дошли до step 11, фиксируем пока то что есть"); //222222222
        //    $State = A2_fix_model($State, "TMP Модель на старте step_11");
        //    $State['next_step'] = 'stop';
        //    return ([$State]);
        if (!isset($State['Presupp']) || count($State['Presupp']) == 0) { //Если модель не содержит Пресуппозицию, то программа переходит к п. 11.1.
            $State = myLog($State, "модель не содержит Пресуппозицию -  программа переходит к п. 11.1");
            // ! Fixed 24/04/22
            // if (!isset($State['IDprevs']) || count($State['IDprevs']) < 1) {
                if (isset($State['IDprevs']) || count($State['IDprevs']) >= 1) {
                // 11.1. Программа находит ближайшую (по расстоянию по времени от т.1 этих моделей до т.3 ВМП) привязанную модель на предшествующем тренде (предшествующую или предшествующую коррекционную).
                // $State = myLog($State, "ERROR -  в п.11.1 - нет IDprevs - фиксируем что есть");
                $State = myLog($State, "В п.11.1 - есть IDprevs, удаляем лишние БО");
                if (!isset($State['param']['alt_old'])) $State['param']['alt_old'] = 0;
                // ! Здесь правим, т.к. если нет ни т.2 ранее определенной,ни Пресуппозиции, ни предшествующих моделей,то получается,что программа пытается фиксировать модели и искать альтернативные модели для модели,у которой не определена t2
                // $State['param']['fixed_at'] = $State['curBar']; //?????????????????
                // $State = A2_fix_model($State, 'Фиксация ВМП на 11.1');
                // $State['next_step'] = 'A2_step_12'; 
                // return [$State];
                // ! Fixed 24/04/22
            // }
                // * Removing all the p12candidates that are before the t1 of the closest previous model. */
                // //для нужд пп.11.1.2.2. сортируем IDprevs по удаленности (в п 11.1 - по расстоянию по времени от т.1 этих моделей до т.3 ВМП)
                // для нужд пп.11.1.1. сортируем IDprevs по удаленности ( по расстоянию по времени от т.1 этих моделей до т.3 ВМП)
                usort($State['IDprevs'], "compare_IDprevs_step11");
                //$bestModel1=false; // искомая привязанной модели в массиве IDprevs
                //$dist=1000; // минимальная расстояние (в начале макс)
                $is11_1done = false; // Флаг используется для того,чтобы при наличии прдешствующей коррекционной модели по тренду поставить False и не рассматривать её т.1 как ограничитель при поиске т.2 
                foreach ($State['IDprevs'] as $pk => $pv) { // перебираем ранее отсортированный по т1(I) массив
                    $arIDprev = explode('-', $pv); // разбиваем ключ IDprev
                    $model_prev = $Models_Alg1[$arIDprev[1]][$arIDprev[2]]; // например если "m1-p891-1-894-2" - берем "p891" и "1"
                    $modelTrendType = $model_prev['param']['G3'];  // параметр G3 из модели первого алгоритма - по тренду или нет(IDPrev // было ошибочно - getModelTrendType_G3($model_prev);
                    $modelType = $arIDprev[4]; // типу модели (непосредственно предшествующя или предшествующая коррекцияонная)
                    //if ($modelTrendType !== "onTrend")
                    //$State['param']['G3'] = $modelTrendType;
                    //11.1.1. Если ближайшая найденная привязанная модель (предшествующая или предшествующая коррекционная) является моделью от начала тренда (а не по тренду),
                    //  то все потенциальные т.2, которые совпадают с баром т.1 найденной привязанной модели и которые лежат до т.1 найденной привязанной модели, отбрасываются.
                    if ($modelTrendType == "BTModel") { // 11.1.1. Если ближайшая найденная привязанная модель (предшествующая или предшествующая коррекционная) является моделью от начала тренда (а не по тренду), то все потенциальные т.2, которые совпадают с баром т.1 найденной привязанной модели и которые лежат до т.1 найденной привязанной модели, отбрасываются. 
                        foreach ($State['p12candidates'] as $pkc => $p12candidate) {
                            if ($p12candidate[0] <= $model_prev['t1']) {
                                $State = myLog($State, "11.1.1. удален кандидат в БО" . $State['p12candidates'][$pkc]);
                                unset($State['p12candidates'][$pkc]);
                            }
                        }
                        // $pv['key'] = $pv['key'] . "-" . "IDprev_1"; // добавляем метку значимой предшествующей
                        $pv = $pv . "-" . "IDprev_1"; // добавляем метку значимой предшествующей
                        // $State['IDprevs'][$pk] = $pv['key'];
                        $State['IDprevs'][$pk] = $pv;
                        $is11_1done = true; // переходим на 11_2

                    } else { //11.1.2. Если ближайшая найденная привязанная модель (предшествующая или предшествующая коррекционная) является моделью по тренду, то
                        //11.1.2.1. При наличии предшествующей модели по тренду отбрасываются все т.2, которые лежат до т.1 предшествующей модели.
                        // Другими словами, т.1 предшествующей может быть т.2 ВМП, а точки, лежащие перед т.1 предшествующей – не могут.
                        if ($modelType == 1) { // типу модели (непосредственно предшествующя
                            foreach ($State['p12candidates'] as $pkc => $p12candidate) {
                                $State = myLog($State, "11.1.2. удален кандадат в БО" . $State['p12candidates'][$pkc]);
                                if ($p12candidate[0] < $model_prev['t1']) unset($State['p12candidates'][$pkc]);
                            }
                            // $pv['key']  =  $pv['key'] . "-" . "IDprev_1"; // добавляем метку значимой предшествующей
                            $pv = $pv . "-" . "IDprev_1"; // добавляем метку значимой предшествующей
                            // $State['IDprevs'][$pk] = $pv['key']; // обновляем маасив предшествующих меткой значимой предшествующей
                            $State['IDprevs'][$pk] = $pv;
                            $is11_1done = true; // переходим на 11_2
                        }
                    }
                    //11.1.2.2. При наличии предшествующей коррекционной модели по тренду программа ищет ещё одну привязанную модель на предшествующем тренде данной ВМП
                    // (следующую по удаленности) и анализирует её в качестве ориентира по данному пункту (п.11.1.). Т.е. программа возвращается к началу пп.11.1.
                    if ($is11_1done) break; // иначе продолжаем цикл = Т.е. программа возвращается к началу пп.11.1.
                    $State = myLog($State, "Отброшены кандидаты в БО перед предшествующей моделью -  программа переходит к п. 11.1");
                } // закончили перебор отсортированного IDprevs
                // ! Fixed 24/04/22
            } else {// 11.1.0. Случай,когда нет IDprevs. Программа переходит к 11.2. 
                // $is11_1done = true;
                $State = myLog($State, "11.1.0. ВМП не имеет предшествующих моделей, программа переходит к п. 11.2.");
            }
        } else {
            // ! Fixed 24/04/22
            // $is11_1done = true;
            $State = myLog($State, "ВМП содержит Пресуппозицию, программа переходит к п. 11.2.");
        }
        // ! Fixed 24/04/22
        // if ($is11_1done) {      //ВМП содержит Пресуппозицию ЛИБО $is11_1done==true - >программа переходит к п. 11.2.
            // 11.2
            //11.2.1. Для специфических моделей программа выбирает в качестве т.2 наиболее удаленную по времени от т.3.
            if (isset($State['param']['E3']) && $State['param']['E3'] == "Specific 1st check" || isset($State['param']['E4']) && $State['param']['E4'] == "Specific 2nd check") {
                $min_ = $State['t3']; // стартовое значение
                //далее ищем индекс самой удаленного кандидата в т.2
                $pk_min = -1;
                foreach ($State['p12candidates'] as $pk => $bo) if ($bo[0] < $min_) {
                    $min_ = $bo[0];
                    $pk_min = $pk;
                }
                if ($pk_min >= 0) foreach ($State['p12candidates'] as $pk => $bo)
                    if ($pk !== $pk_min) unset($State['p12candidates'][$pk]);
                    else $State['t2'] = $bo[0];
                else {
                    // unset($State['t2']);   
                    $State['next_step'] = 'stop';
                    $State = myLog($State, "ERROR - не осталось БО в 11.2.1");
                    return ($State);
                }
            } else { //11.2.2. Для простых моделей в качестве т.2 выбирается максимально приближенная по времени к т.3.
                $max_ = 0; // стартовое значение
                //далее ищем индекс самой удаленной T2 кандидата
                $pk_max = -1;
                foreach ($State['p12candidates'] as $pk => $bo) if ($bo[0] > $max_) {
                    $max_ = $bo[0];
                    $pk_max = $pk;
                }
                if ($pk_max >= 0) foreach ($State['p12candidates'] as $pk => $bo)
                    if ($pk !== $pk_max) unset($State['p12candidates'][$pk]);
                    else $State['t2'] = $bo[0];
                else {
                    // unset($State['t2']);
                    $State['next_step'] = 'stop';
                    $State = myLog($State, "ERROR - не осталось БО в 11.2.2");
                    return ($State);
                }
            }
            // ! Fixed 24/04/22
        // } // закончили 11.2
    }
    // ! fixed 24/04/22  ПЕРЕПИСАТЬ КОММЕНТАРИИ! ВНЕСТИ В ТЕКСТ АЛГОРИТМА! 
    else { // 11. alfa Если в начале п. 11 есть т.2 (например ищём альтернативную модель) 
        usort($State['IDprevs'], "compare_IDprevs_step11");
        //$bestModel1=false; // искомая привязанной модели в массиве IDprevs
        //$dist=1000; // минимальная расстояние (в начале макс)
        //// $is11_1done = false; // не особо понятно пока, но сделал флаг, что 11.1 отработал и законно перешли в 11.2 (не просто закончили перебор в цикле а было срабатывание "переход на 11.2")
        foreach ($State['IDprevs'] as $pk => $pv) { // перебираем ранее отсортированный по т1(I) массив
            $arIDprev = explode('-', $pv); // разбиваем ключ IDprev
            $model_prev = $Models_Alg1[$arIDprev[1]][$arIDprev[2]]; // например если "m1-p891-1-894-2" - берем "p891" и "1"
            $modelTrendType = $model_prev['param']['G3'];  // параметр G3 из модели первого алгоритма - по тренду или нет(IDPrev // было ошибочно - getModelTrendType_G3($model_prev);
            $modelType = $arIDprev[4]; // типу модели (непосредственно предшествующя или предшествующая коррекцияонная)
            //if ($modelTrendType !== "onTrend")
            //$State['param']['G3'] = $modelTrendType;
            //// 11.1.1. Если ближайшая найденная привязанная модель (предшествующая или предшествующая коррекционная) является моделью от начала тренда (а не по тренду),
            ////  то все потенциальные т.2, которые совпадают с баром т.1 найденной привязанной модели и которые лежат до т.1 найденной привязанной модели, отбрасываются.
            if ($modelTrendType == "BTModel") { // 11 alfa 1.1. Модель является моделью от начала тренда и...
                // foreach ($State['p12candidates'] as $pkc => $p12candidate) { // ! не нужно,т.к. уже есть т.2
                    // $State = myLog($State, "11.1.1. удален кандидат в БО" . $State['p12candidates'][$pkc]);
                    // if ($p12candidate[0] <= $model_prev['t1']) unset($State['p12candidates'][$pkc]);

                    // т.2 рассматриваемой модели лежит ранее или совпадает с т.1 предшествующей модели
                    if (isset($State['t2']) && $State['t2'] <= $model_prev['t1']) { // ! поправить,первое условие излишнее
                        // Если в п.10 была установлена заглушка = БО,который теперь окажется исключен из возможных БО,она (заглушка) должна быть удалена
                        unset($State['t2']); // ! поправить,излишнее
                        $State['next_step'] = 'stop'; 
                        $State = myLog($State, "т.2 отброшена, из-за ограничения по предшествующей модели. ");
                        return ($State);
                    }  
                // }
                // // $pv['key'] = $pv['key'] . "-" . "IDprev_1"; // добавляем метку значимой предшествующей
                // $pv = $pv . "-" . "IDprev_1"; // добавляем метку значимой предшествующей
                // // $State['IDprevs'][$pk] = $pv['key'];
                // $State['IDprevs'][$pk] = $pv;
                // $is11_1done = true; // переходим на 11_2

            } else { //11 alfa.1.2. Если ближайшая найденная привязанная модель (предшествующая или предшествующая коррекционная) является моделью по тренду, то
                // // 11.1.2.1. При наличии предшествующей модели по тренду отбрасываются все т.2, которые лежат до т.1 предшествующей модели.
                // // Другими словами, т.1 предшествующей может быть т.2 ВМП, а точки, лежащие перед т.1 предшествующей – не могут.
                if ($modelType == 1) { // типу модели (непосредственно предшествующя
                    // foreach ($State['p12candidates'] as $pkc => $p12candidate) { // ! не нужно,т.к. уже есть т.2
                        // $State = myLog($State, "11.1.2. удален кандадат в БО" . $State['p12candidates'][$pkc]);
                        // if ($p12candidate[0] < $model_prev['t1']) unset($State['p12candidates'][$pkc]);
                        if (isset($State['t2']) && $State['t2'] < $model_prev['t1']) {
                            // Если в п.10 была установлена заглушка = БО,который теперь окажется исключен из возможных БО,она (заглушка) должна быть удалена
                            unset($State['t2']);  // ! поправить,излишнее
                            $State['next_step'] = 'stop';
                            $State = myLog($State, "т.2 отброшена, из-за ограничения по предшествующей модели");
                            return ($State);
                        } 
                    // }
                    // // $pv['key']  =  $pv['key'] . "-" . "IDprev_1"; // добавляем метку значимой предшествующей
                    // $pv = $pv . "-" . "IDprev_1"; // добавляем метку значимой предшествующей
                    // // $State['IDprevs'][$pk] = $pv['key']; // обновляем маасив предшествующих меткой значимой предшествующей
                    // $State['IDprevs'][$pk] = $pv;
                    // $is11_1done = true; // переходим на 11_2
                }
            }
            // //11.1.2.2. При наличии предшествующей коррекционной модели по тренду программа ищет ещё одну привязанную модель на предшествующем тренде данной ВМП
            // // (следующую по удаленности) и анализирует её в качестве ориентира по данному пункту (п.11.1.). Т.е. программа возвращается к началу пп.11.1.
            // if ($is11_1done) break; // иначе продолжаем цикл = Т.е. программа возвращается к началу пп.11.1.
            // $State = myLog($State, "Отброшены кандидаты в БО перед предшествующей моделью -  программа переходит к п. 11.1");
        } // закончили перебор отсортированного IDprevs
    } // * Закончили блок,в котором т.2 определена заранее (скорей всего поиск альтернативной модели)
    // 11.3. Алгоритм рассчитывает уровень пересечения ЛЦ  и ЛТ ВМП (далее – расчётная т.6). Проверяется положение т.5 по отношению к уровню расчётной т.6. . Возможны 2 варианта:
    $LT = A2_LT($State);
    $LC = A2_LC($State);
    $_CP = linesIntersection($LT, $LC);
    if ($_CP && high($State['t5'], $v) <= $_CP['level']) { //11.3.1. Если бар т.5 не пробивает уровень расчётной т.6, то программа проверяет,была ли найдена т.5"

        if (isset($State['t5"'])) { // 11.3.1.1. Если т.5" была найдена, то осуществляется проверка на сходимость лини ЛТ" и ЛЦ
            $v = $State['v'];
            $t3_ = (isset($State['t3\''])) ? 't3\'' : 't3';
            if (isset($State['t3"'])) $t3_ = 't3"';
            $LT_ss = (['bar' => $State[$t3_], 'level' => low($State[$t3_], $v), 'angle' => (low($State['t5"'], $v) - low($State[$t3_], $v)) / ($State['t5"'] - $State[$t3_])]);
            // $y_top = lineLevel($LC, $t3_); // цена на ЛЦ" на баре  т.3/т.3'/т.3"
            // $y_bottom = low($t3_, $v);
            $dy = $LT_ss['angle'] - $LC['angle'];
            if ($dy > 0) {
                $_CP2 = linesIntersection($LT_ss, $LC);
                if (($State['t4'] - $State['t2']) / ($_CP2['bar'] - $State['t4']) < B24to46) { //11.3.1.1.А. Если отношение расстояния в барах между т.2 и т.4 к расстоянию между т.4 и расчетной т.6" меньше значения по умолчанию параметра «Минимальное отношение т.2-т.4 к т.4-т.6 ВМП», то т.5" отбрасывается.
                    unset($State['t5"']);
                    $State = myLog($State, "Отбрасываем т.5\" - ЛЦ и ЛТ\" сходятся слишком далеко, на расстоянии =" . ($State['t4'] - $State['t2']) / ($_CP2['bar'] - $State['t4']) . " при B24to46 =" . B24to46 . " State['t4'] = " . $State['t4'] . " State['t2'] = " . $State['t2'] . " t6\" = " . $_CP2['bar'] . " State['t4'] = " . $State['t4'] . " dy = " . $dy . " t3_ = " . $t3_);
                }
            } else { // 11.3.1.1.Б.Если ЛТ" и ЛЦ расходятся, то т.5" отбрасывается.
                $State = myLog($State, "Линии ЛТ\" и ЛЦ расходятся dy =" . $dy . "unset 5\" - " . $State['t5"']);
                unset($State['t5"']);
            }
        } // 11.3.1.2. Если т.5" отсутствует программа фиксирует модель. 

        // программа фиксирует модель.
        if (!isset($State['param']['alt_old'])) $State['param']['alt_old'] = 0;
        $State['param']['fixed_at'] = $State['curBar']; //???????????
        $State = A2_fix_model($State, 'Фиксация ВМП на 11.3.1');
        $State['next_step'] = 'A2_step_12';
        return ($State);
    } else { // 11.3.2. Если бар т.5 пробивает уровень расчётной т.6, то данная МП не может быть построена программа ищет новую т.5, для чего обрабатывает бар, следующий за баром т.5   по п.2 и далее по алгоритму.
        $State = myLog($State, "11.3.2.  - ищем новую т5 - переход на step_2");
        $State['next_step'] = 'A2_step_2'; // программа ищет следующую потенциальную т.5 и т.4 в соответствии с п.2.
        $State['curBar'] = $State['t5'] + 2;
        $State = clearState($State, "t3,A2Prev");
        return ($State);
    }
}
function A2_step_12($State)
{
    global $res, $splitCnt;
    $State = A2_myLog_start($State, "12");
    // $State = A2_fix_model($State, 'Фиксация ВМП на step_12');
    $State['next_step'] = 'stop';
    if ($State['draw_flag'] ?? false) {
        $State['next_step'] = 'stop';
        return ($State);
    }

    if (isset($State['conf_t4'])) {
        $State = myLog($State, " step 12 - запускаем поиск альтернативных моделей");
        $State2 = $State;
        $State2['next_step'] = 'A2_step_2';
        $State2['status'] = $State2['param'] = [];
        $State2['param']['alt_old'] = $State['param']['alt_old'] + 1;
        if (isset($State2['flat_log'])) $State2['flat_log'] = [];
        $State2['split'] = $splitCnt;
        //$State2['param']['alt_old']++;
        $State2['curBar'] = $State['conf_t4'] + 1;
        $State2 = clearState($State2, "t1p,t2p,t3p,t4p,t1,t2,t3,A2Prev");
        $State2 = myLog($State2, "Новая ветка [$splitCnt] поиска альтернативной модели с бара (" . ($State['conf_t4'] + 1));
        $splitCnt++;
    }
    if (isset($State2)) return ([($State), $State2]);
    else return ([($State)]);
}

function A2_getModelTrendType_G3($model)
{ // Определение модели «по тренду» или «от начала тренда».
    // вначале ищем пересечение ценой уровня т1 (либо глубина 50 бар:
    $v = $model['v'];
    $t3_level = low($model['t3'], $v); // уровень t3
    $t4_level = high($model['t4'], $v); // уровень t4
    $t4_broken = false; //    1. найдено пересечение ценой уровня т.4
    $t3_broken = false; //    2. найдено пересечение ценой уровня т.3
    $limitBar = $model['t3'] - CALC_G3_DEPTH; // левая граница поиска
    if ($limitBar < 0) $limitBar = 0;
    for ($i = $model['t3'] - 1; $i >= $limitBar; $i--) {  // Е: не включая?
        if (high($i, $v) > $t4_level) {
            $t4_broken = $i;
            break;
        }
        if (low($i, $v) < $t3_level) {
            $t3_broken = $i;
            break;
        }
    }
    if ($t3_broken === false && $t4_broken === false) { //-Если программа проверила менее 50 баров до т.3 модели и достигнут начальный бар графика,
        //  а искомое пересечение не найдено, модель рассматривается как  модель от начала тренда в отчете отображается: G3=NoData
        return ("NoData"); // модель от начала тренда
    }
    //-Если найдено пересечение т.3 до того, как найдено пересечение т.4, то модель является моделью по тренду в отчете отображается:G3=HTModel
    // Е: "до того" - это по времени на графике или по циклу (который назад) ? !!!!!!!!!!!!!!!
    if ($t4_broken === false || $t3_broken > $t4_broken) {
        return ("HTModel");
    }
    return ("BTModel");
}

function A2_LT_ss($State) // ЛТ ВМП через т.5"
{
    global $res;
    $v = $State['v'];
    $t3_ = (isset($State['t3\''])) ? 't3\'' : 't3';
    if (isset($State['t3"'])) $t3_ = 't3"';
    $i = $State['t5"'];
    if ($i == $State[$t3_]) { //22222222222222
        $res['log'][] = "ERROR A2_LT_ss - split=" . $State['split'];
        JSON_log(["State" => $State, "txt" => ("Ошибка в A2_LT_ss (Деление на 0] i=$i=State[t3_]=" . $State[$t3_])], "ERR_A2_LT_ss.json");
    }

    return (['bar' => $State[$t3_], 'level' => low($State[$t3_], $v), 'angle' => (low($i, $v) - low($State[$t3_], $v)) / ($i - $State[$t3_])]);
}



function LC($State)
{ // определение линии целей
    $v = $State['v'];
    return (['bar' => $State['t2'], 'level' => high($State['t2'], $v), 'angle' => (high($State['t4'], $v) - high($State['t2'], $v)) / ($State['t4'] - $State['t2'])]);
}

function LCs($State)
{ // определение ЛЦ'
    $v = $State['v'];
    $t2_ = (isset($State['t2\''])) ? 't2\'' : 't2';
    return (['bar' => $State[$t2_], 'level' => high($State[$t2_], $v), 'angle' => (high($State['t4'], $v) - high($State[$t2_], $v)) / ($State['t4'] - $State[$t2_])]);
}
function A2_LC($State)
{ // определение ЛЦ'
    $v = $State['v'];
    // $t2_ = (isset($State['t2\''])) ? 't2\'' : 't2';
    return (['bar' => $State['t2'], 'level' => high($State['t2'], $v), 'angle' => (high($State['t4'], $v) - high($State['t2'], $v)) / ($State['t4'] - $State['t2'])]);
}

function LT($State)
{ // определение линии тренда
    $v = $State['v'];
    $t3_ = (isset($State['t3\''])) ? 't3\'' : 't3';
    return (['bar' => $State['t1'], 'level' => low($State['t1'], $v), 'angle' => (low($State[$t3_], $v) - low($State['t1'], $v)) / ($State[$t3_] - $State['t1'])]);
}

function A2_LT($State)
{ // определение линии тренда
    $v = $State['v'];
    $t3_ = (isset($State['t3\''])) ? 't3\'' : 't3';
    return (['bar' => $State[$t3_], 'level' => low($State[$t3_], $v), 'angle' => (low($State['t5'], $v) - low($State[$t3_], $v)) / ($State['t5'] - $State[$t3_])]);
}


function A2_fix_model($State, $name, $wo_t5 = false)
{ // фиксируем модель - пополняем общую коллекцию моделей в $res['Models']
    global $res, $modelNextId, $Chart, $maxBar4Split, $curSplit, $pips;
    $v = $State['v'];
    $K = ($v == 'low') ? 1 : -1;
    static $TMP_fix_cnt = 0;
    $model = [];
    $State['param']['G1'] = 'EAM';
    //if($State['t3']==719&&$TMP_fix_cnt==1)return($State);
    //if(!isset($State['status']))$State['status']=[];
    // доп.блок - определяем G3 (модель по тренду или нет
    $State['param']['G3'] = A2_getModelTrendType_G3($State);
    // доп.блок - добавляемм служебный параметр _CROSS_POINT - пересечение ЛТ и ЛЦ'
    $LT = A2_LT($State);
    $LC = A2_LC($State);

    $_CP = linesIntersection($LT, $LC);

    // if ($_CP && $_CP['bar'] > $State['t4'])
    if ($_CP) { //проверка что точка пересечения найдена - линии не параллельны
        if (abs($_CP['level']) == 0) $State['status']['ЗАГАДОЧНАЯ ОШИБКА С _cross_point max_bar=' . date("Y-m-d H:i:s", $Chart[nBars - 1]['close_time'])] = 0;
        // else $State['param']['_cross_point'] = substr(" " . $_CP['bar'], 1, 7) . " (" . substr(" " . abs($_CP['level']), 1, 7) . ")";
        else {
            $State['param']['_cross_point'] = round($_CP['bar'], 3) . " (" . round(abs($_CP['level']), 5) . ")";
            $State['param']['calcP6'] = round(abs($_CP['level']), 5);
            $State['param']['calcP6t'] = round($_CP['bar'], 3);
            // !! Added 14/02/22
            // $State['param']['TLSpeedEAM'] = round($LT['angle']*(high($State['t4'], $v) - low($State['t3'], $v)),2);
            if (
                isset($State['param']['calcP6'])
                && abs($State['param']['calcP6'] * $K - high($State['t2'], $v)) != 0
            ) {
                $State['param']['TLSpeedEAM'] = round($LT['angle'] / abs($State['param']['calcP6'] * $K - high($State['t2'], $v)), 4);
                $State['param']['SpeedEAM'] = round($LT['angle'] / $LC['angle'], 2);
                $State['param']['EAMSize'] = round(abs($State['param']['calcP6'] * $K - low($State['t3'], $v)) / $pips, 0);
                // $State['param']['lowt3'] = low($State['t3'], $v)*$K;
                // $State['param']['p6t3'] = round(abs($State['param']['calcP6']*$K - low($State['t3'], $v)),5);
                $State['param']['EAMSizeT'] = round(abs($State['param']['calcP6t'] - $State['t2']), 0);
                $State['param']['pips'] = $pips;
            }
        }
    } else { // линии  параллельны
        // тут можно что-то сообщить, если надо :)
    }
    if (isset($State['t5"'])) {     // еще один - если есть t5" - определяем еще одну линию тренда (через t5")
        $State = myLog($State, "Присутствует t5\" - считаем LT_ss");
        $LT_ss = A2_LT_ss($State);
        $_CP_ss = linesIntersection($LT_ss, $LC);
        // $State['param']['_cross_point2'] = substr(" " . $_CP_ss['bar'], 1, 7) . " (" . substr(" " . abs($_CP_ss['level']), 1, 7) . ")";
        if ($_CP_ss) { // добравлено 2021-03-03 так как при пересчете по всем 35 парам Альпари встретился случай, когла линии СТРОГО параллельны
            $State['param']['_cross_point2'] = round($_CP_ss['bar'], 3) . " (" . round(abs($_CP_ss['level']), 5) . ")";
            $State['param']['calcP6"'] = round(abs($_CP_ss['level']), 5);
            $State['param']['calcP6"t'] = round($_CP_ss['bar'], 3);
            // !! Added 14/02/22
            // $State['param']['TLSpeedEAM5"'] = round($LT_ss['angle']/$pips*1000,2);
            // $State['param']['TLSpeedEAM5"'] = round($LT_ss['angle']*(high($State['t4'], $v) - low($State['t3'], $v)),2);
            if (
                isset($State['param']['calcP6"'])
                && abs($State['param']['calcP6"'] * $K - high($State['t2'], $v)) != 0
            ) {
                $State['param']['TLSpeedEAM5"'] = round($LT_ss['angle'] / abs($State['param']['calcP6"'] * $K - high($State['t2'], $v)), 4);
                $State['param']['SpeedEAM5"'] = round($LT_ss['angle'] / $LC['angle'], 2);
                $State['param']['EAMSize"'] = round(abs($State['param']['calcP6"'] * $K - low($State['t3'], $v)) / $pips, 0);
                $State['param']['EAMSizeT"'] = round(abs($State['param']['calcP6"t'] - $State['t2']), 0);
                $State['param']['pips'] = $pips;
            }
        }
    }
    // конец доп.блока _CROSS_POINT
    if ($name) $State['status'][$name] = 0; // J не совсем ясно что и зачем?
    $State['param']['_points'] = $newModelPoints = modelPoints($State, $wo_t5); // ЗАГЛУШКА тест
    $State = myLog($State, "!!! Фиксируем модель [$name]: $newModelPoints ");
    static $field_names = ['v', 'alt_old', 'draw_flag', 'split', 'status', 'param', '$confirmP2', 't1', 't2', 't3', 't3\'', 't4', 't5', 't5"', 't3"', 'A2Prev', 'p12candidates', 'Presupp', 'IDinners', 'IDprevs', 'conf_t4']; // поля, которые заносим в модель
    foreach ($field_names as $pk => $pv) {
        if (isset($State[$pv])) $model[$pv] = $State[$pv];
    }

    $model['param']['max_bar'] = $maxBar4Split[$curSplit];
    // пополняем общую коллекцию моделей в $res['Models']
    $t3 = $State['t3'];
    if (!isset($res['Models'][$t3])) {
        $model['id'] = $modelNextId++;
        $res['Models'][$t3] = [$model]; // массив, пока из одной модели по ключу t3
    } else { // ключ т3 уже есть
        // на всякий случай ищем дубликаты (вроде, их не должно быть там...)
        $isDublicateFound = false;

        foreach ($res['Models'][$t3] as $pk => $pv) // каждый подмассив точек, относящийся к индексу [$t3]
            if ($pv['param']['_points'] == $newModelPoints) { // проверяется на то, чтобы точки, содержащиеся в каждом из массивов [$t3] (как $pv здесь) не совпадали с точками, определяющими уникальную модель в рассматриваемой модели
                $isDublicateFound = $pk;
                break;
                //$res['log'][]="ОШИБКА - дубликат модели на $t3 ".$model['v'];
            }
        if ($isDublicateFound === false) {
            $model['id'] = $modelNextId++;
            $res['Models'][$t3][] = $model;
        } else { // модель с такими же ключевыми точками найдена
            //            if(($State['draw_flag'] ?? false)===true){$State=myLog($State,"Попытка повторной фиксации с draw_flag заблокирована");return($State);}
            //            unset($res['Models'][$t3][$isDublicateFound]['draw_flag']);
            //            foreach ($model['status'] as $pk => $pv) if (!isset($res['Models'][$t3][$isDublicateFound]['status'][$pk])) $res['Models'][$t3][$isDublicateFound]['status'][$pk] = $pv;
            //            //foreach($model['param'] as $pk=>$pv)$res['Models'][$t1][$isDublicateFound]['param'][$pk]=$pv;
            //            $res['Models'][$t3][$isDublicateFound]['param'] = $model['param'];
            //            foreach ($field_names as $pk => $pv) if ($pv !== 'status' && $pv !== 'param') {
            //                if (isset($model[$pv])) $res['Models'][$t3][$isDublicateFound][$pv] = $model[$pv];
            //            }

            if (($State['draw_flag'] ?? false) === true) {
                $State = myLog($State, "Попытка повторной фиксации с draw_flag заблокирована");
                return ($State);
            }
            $model['id'] = $res['Models'][$t3][$isDublicateFound]['id'];
            $res['Models'][$t3][$isDublicateFound] = $model;
        }
    }
    //if($State['t3']==719)JSON_log($State,"TMP__719_".$TMP_fix_cnt++.".json");
    return ($State);
}

// function modelPoints($model, $wo_t5 = false)
function modelPoints($StateX, $wo_t5 = false)
{
    static $point_names = ['t1', 't2', 't3', 't4', 't5']; // поля, которые определяют уникальную модель
    $points = "";
    // добавлено исключение т5, когда это нужно, напр. пп.6.2.1.1.2, пп.6.2.2.1.2 Алгоритма 1
    foreach ($point_names as $pk => $pv) if (!$wo_t5 || $pv !== 't5') { // если $wo_t5 положительное, то т.5 пропускается
        // if (isset($model[$pv])) $points .= $pv . ":" . $model[$pv] . " "; // $pv - это название точки, а $model[$pv] - это номер бара данной точки
        if (isset($StateX[$pv])) $points .= $pv . ":" . $StateX[$pv] . " "; // $pv - это название точки, а $StateX[$pv] - это номер бара данной точки
        // получается, что для всех точек, номера баров которых определены в массиве $StateX, название + номер бара этих точек добавляютсяв переменную $points через пробел
    }
    return (trim($points)); // таким образом данная функця возвращает  названия + значения точек, слоты для которых есть в $StateX
}


function A2_next_T3($State)
{ // переход в новой Т1 с проверками, нужно ли продолжать
    global $res;
    // Е: 20200814 - поменяли подход, теперь ветвление для поиска новой т3 приисходит при нахождении кандидата на step_1 -
    // данная функция теперь просто завершает ветку с пометкой, что т3 неудачная
    // все, что ниже return - оставлено для справки (что было раньше)
    //
    $State = myLog($State, " Т3 отклонена - завершаем данный State");
    $State['next_step'] = 'stop';
    return ($State);
    /////////////////////////////////////////////////
    if ($State['mode'] == 'selected') {
        $State = myLog($State, "Завершение ветки - mode=selected = изменение t3 ВМП запрещено");
        //      $State=fix_model($State,"ОТЛАДКА - фиксация при смене т.1"); ///////////////////////////ЗАГЛУШКА
        $State['next_step'] = 'stop';
        return ($State);
    }
    if ($State['t3'] < 3) {
        $State = myLog($State, "Завершение ветки - дошли до начала графика");
        $State['next_step'] = 'stop';
        return ($State);
    }
    if ($State['mode'] == 'last') { // переходим к новой т1 только если не были зафиксированы модели
        $v = $State['v'];
        foreach ($res['Models'] as $pk => $pv) // во всех моделях...
            foreach ($pv as $pk1 => $pv1) { // среди всех свойств моделей...
                if ($pv1['v'] == $v) { // при наличии совпадающей по направлению модели...
                    $State = myLog($State, "Завершение ветки - mode = last и уже есть зафиксированные модели");
                    $State['next_step'] = 'stop';
                    return ($State);
                }
            }
    }
    $State['curBar'] = $State['t3'] - 1;
    //    $State=myLog($State," tmp_log: передвинули cur_bar(t3) на ".$State['curBar']); //222222222222
    $State['next_step'] = 'A2_step_1';
    $State = clearState($State, "t3");
    $State['param'] = [];
    $State['status'] = [];
    return ($State);
}




function calcStatistics()
{ // получение финальной статистики по найденным моделям
    global $res;
    // J не догоняю, что в блоке ниже происходит
    if ($res['info']['mode'] == 'last') { // оставляем только последние low и high (возможны лишние при разщеплениях алгоритма, увы
        $last_low = false;
        $last_high = false;
        foreach ($res['Models2'] as $pk => $pv) foreach ($pv as $pk1 => $pv1) {
            if ($pv1['v'] == 'low') if (!$last_low || $last_low < $pk) $last_low = $pk;
            if ($pv1['v'] == 'high') if (!$last_high || $last_high < $pk) $last_high = $pk;
        }
        foreach ($res['Models2'] as $pk => $pv) {
            $ar = [];
            foreach ($pv as $pk1 => $pv1) {
                if ($last_low && $pv1['v'] == 'low' && $last_low == $pk) $ar[] = $pv1;
                if ($last_high && $pv1['v'] == 'high' && $last_high == $pk) $ar[] = $pv1;
            }
            if (count($ar) == 0) unset($res['Models2'][$pk]);
            else $res['Models2'][$pk] = $ar;
        }
    }


    $res['info']['models_total'] = [];
    foreach ($res['Models2'] as $pk => $pv) foreach ($pv as $pk1 => $pv1) {
        $key = $pv1['v'];
        if (isset($res['info']['models_total'][$key])) $res['info']['models_total'][$key]++;
        else $res['info']['models_total'][$key] = 1;
    }
    foreach ($res['Models2'] as $pk => $pv) foreach ($pv as $pk1 => $pv1) {
        foreach ($pv1['status'] as $pk2 => $pv2) {
            $key = $pk2;
            if (isset($res['info']['models_total'][$key])) $res['info']['models_total'][$key]++;
            else $res['info']['models_total'][$key] = 1;
        }
    }
    return ($res);
}
